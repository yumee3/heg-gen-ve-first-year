// AIDEMEMOIRE JAVA COMPLET POUR R√âVISION

// ‚ö†Ô∏è Toutes les sections sont identifi√©es par des commentaires // üîç [numero] TITRE
// Utilise Ctrl+F pour naviguer rapidement !

/*
==========================================================
INDEX DU FICHIER AIDE-MEMOIRE JAVA POUR L'EPREUVE
==========================================================

[1] COMMENTAIRES
[2] MOTS-CL√âS R√âSERV√âS EN JAVA
[3] TYPES DE VARIABLES EN JAVA
[4] CONSTANTES AVEC LE MOT-CL√â FINAL
[5] OP√âRATEURS EN JAVA
[6] CARACT√àRES SP√âCIAUX EN JAVA
[7] PORT√âE DES VARIABLES EN JAVA
[8] SYSTEM.OUT.PRINTLN
[9] D√âCLARATION ET INSTANTIATION D‚ÄôOBJETS
[10] MODIFICATEURS EN JAVA
[11] CONDITIONS
[12] BOUCLES EN JAVA
[13] M√âTHODES & PARAM√àTRES
[14] PASSAGE PAR VALEUR VS PAR R√âF√âRENCE
[15] M√âTHODE MAIN
[16] GETTERS & SETTERS
[17] CONSTRUCTEURS EN JAVA
[18] M√âTHODES G√âN√âRALES UTILES
[19] M√âTHODES UTILIS√âES FR√âQUEMMENT (compl√©ment)
[20] JAVADOC
[21] TABLEAUX (1 dimension)
[22] MATRICES (tableaux √† 2 dimensions)
[23] LISTES DYNAMIQUES : ARRAYLIST, LINKEDLIST, VECTOR
[24] DICTIONNAIRE : HASHMAP
[25] ITERATOR
[26] ENSEMBLES (SET) : HASHSET, TREESET
[27] OBJETS & APPELS
[28] ABSTRACTION & MODULARISATION
[29] H√âRITAGE, INTERFACES & POLYMORPHISME
    - 29.1 extends, superclasse, sous-classes
    - 29.2 constructeurs avec super()
    - 29.3 droits d‚Äôacc√®s : private, protected, public
    - 29.4 classes abstraites & m√©thodes concr√®tes
    - 29.5 Interface ICallable : constante, getNom(), setNom()
    - 29.6 Type statique vs type dynamique
    - 29.7 override vs overloading
    - 29.8 Comparable, Comparator, equals & hashCode

[30] CARTES CRC
[31] STRUCTURATION D‚ÄôUN PROJET JAVA
[32] UTILISATION DES BIBLIOTH√àQUES
[33] CLASSES UTILES : STRING, INTEGER, MATH, RANDOM
[34] COLLECTIONS : M√âTHODES UTILES

[35] GESTION DES EXCEPTIONS EN JAVA
    - 35.1 try/catch/finally
    - 35.2 throws et throw
    - 35.3 Exceptions personnalis√©es
    - 35.4 Exception vs Error
    - 35.5 Cas pratiques d‚Äôexamen

[36] COMPARAISONS EN JAVA
    - 36.1 == vs .equals()
    - 36.2 equals() et hashCode()
    - 36.3 instanceof
    - 36.4 compareTo() et Comparable
    - 36.5 Comparator

[37] CAS SP√âCIAUX VUS EN EXAMENS
    - 37.1 Examen blanc 2023 ‚Äì Gestion des examens
    - 37.2 Examen cin√©ma ‚Äì HashSet / HashMap / equals
    - 37.3 Examen votation ‚Äì Validations & Exceptions personnalis√©es
    - 37.4 Examen gestion des alarmes ‚Äì Null, out of bounds, type
    - 37.5 Cast foireux (ClassCastException)
    - 37.6 Mauvais .equals() sur null

[38] LECTURE & CHARGEMENT DE DONN√âES
    - 38.1 Lecture ligne par ligne (BufferedReader)
    - 38.2 Chargement CSV dans int[]
    - 38.3 Chargement CSV dans int[][]
    - 38.4 Chargement CSV dans ArrayList<String[]>
    - 38.5 Chargement CSV dans String[][]
    - 38.6 M√©thode lireCsv (style HEG, retourne String[])
    - 38.7 Exemple complet avec double tableau + objets (Livre)
    - 38.8 Exercice Forum Admin, modo
    - 38.9 Chargement via SPLIT ou non (FileToStr)


[39] LISTES & MOT-CL√â `new` : BONNES PRATIQUES
    - 39.1 Quand utiliser `new` pour cr√©er une liste
    - 39.2 Cas o√π `new` est inutile (param√®tres, transferts, etc.)
    - 39.3 R√©sum√© & comparaison de cas concrets

[40] LIAISON ENTRE OBJETS SANS HASHMAP (EXAMEN 2023)


==========================================================
Astuce : utilisez Ctrl+F + le numero pour retrouver un point precis rapidement.
==========================================================
*/


// =======================================
// üîç [1] COMMENTAIRES
// =======================================
// Ceci est un commentaire mono-ligne
/* Ceci est
   un commentaire multi-ligne */

// =======================================
// üîç [2] MOTS-CLES RESERVES EN JAVA
// =======================================

import ExaQ2_ForumEnLigne.*;
import ExaQ3_DrugManagement.*;

import java.io.IOException;
import java.util.*;

/**
     * public : accessible depuis partout
     */
    public class MaClassePublic {}

    /**
     * private : accessible uniquement dans la classe
     */
    private int compteur;

    /**
     * class : d√©finit une classe
     */
    class Utilisateur {}

    /**
     * static : appartient √† la classe plut√¥t qu‚Äô√† l‚Äôinstance
     */
    public static int totalUtilisateurs;

    /**
     * void : m√©thode qui ne retourne rien
     */
    public void afficher() {
        System.out.println("Salut !");
    }

    /**
     * new : cr√©e une nouvelle instance
     */
    Utilisateur u = new Utilisateur();

    /**
     * return : renvoie une valeur depuis une m√©thode
     */
    public int addition(int a, int b) {
        return a + b;
    }

    /**
     * if : ex√©cute une instruction si la condition est vraie
     * else : ex√©cute une autre instruction sinon
     */
    if (a > b) {
            System.out.println("a est plus grand");
        } else {
            System.out.println("b est plus grand ou √©gal");
        }

    /**
     * for : boucle avec compteur
     */
    for (int i = 0; i < 10; i++) {
            System.out.println(i);
        }

    /**
     * while : boucle tant que la condition est vraie
     */
    while (a < 5) {
            a++;
        }

    /**
     * break : sort imm√©diatement de la boucle
     * continue : passe √† l‚Äôit√©ration suivante
     */
    for (int i = 0; i < 10; i++) {
            if (i == 5) break;
            if (i % 2 == 0) continue;
            System.out.println(i);
        }

    /**
     * switch / case / default : s√©lectionne parmi plusieurs blocs de code
     */
    switch (jour) {
            case "lundi": System.out.println("D√©but"); break;
            case "vendredi": System.out.println("Fin"); break;
            default: System.out.println("Milieu");
        }

    /**
     * import : inclut une classe externe
     */
    import java.util.ArrayList;

    /**
     * package : d√©finit l‚Äôemplacement logique d‚Äôune classe
     */
    package monprogramme.utilitaires;

    /**
     * implements : indique qu‚Äôune classe impl√©mente une interface
     */
    class Chien implements IAnimal {
        public void parler() {
            System.out.println("Wouf");
        }
    }

    /**
     * extends : indique qu‚Äôune classe h√©rite d‚Äôune autre
     */
    class Chien extends Animal {}

    /**
     * try / catch / finally : gestion des exceptions
     */
    try {
            int result = 10 / 0;
        } catch (ArithmeticException e) {
            System.out.println("Erreur");
        } finally {
            System.out.println("Bloc toujours ex√©cut√©");
        }

        /**
         * this : fait r√©f√©rence √† l‚Äôinstance courante
         */
        public void setNom(String nom) {
            this.nom = nom;
        }

        /**
         * super : fait r√©f√©rence √† la superclasse
         */
        class Chien extends Animal {
            public Chien(String nom) {
                super(nom);
            }
        }

    /**
     * instanceof : teste si un objet est d‚Äôun type donn√©
     */
    if (animal instanceof Chien) {
            System.out.println("C‚Äôest un chien");
        }

    /**
     * abstract : classe ou m√©thode non impl√©ment√©e
     */
    abstract class Forme {
        public abstract double aire();
    }

    /**
     * final : emp√™che la modification (classe, m√©thode ou variable)
     */
    final int MAX = 100;

    /**
     * synchronized : emp√™che l‚Äôacc√®s simultan√© √† une m√©thode en multithread
     */
    public synchronized void incrementer() {
        compteur++;
    }

    /**
     * volatile : garantit la lecture directe de la variable en m√©moire (thread-safe)
     */
    private volatile boolean actif = true;

    /**
     * transient : emp√™che la s√©rialisation d‚Äôun attribut
     */
    private transient String motDePasse;

    // Ajouter un sout en plus a un abstarct dja defini

    @Override
    public void messageDeconnexion() {
        super.messageDeconnexion();
        System.out.println("Il √† r√©gler " + nbBugs + " aujourd'hui. Bravo");
}

// =======================================
// üîç [3] TYPES DE VARIABLES EN JAVA
// =======================================

/**
 * üîπ Les types primitifs stockent une valeur brute directement en m√©moire.
 * üîπ Les types objets stockent une r√©f√©rence vers une zone m√©moire.
 * üîπ Les types primitifs ne peuvent pas √™tre null, contrairement aux objets.
 * üîπ Les types primitifs sont plus rapides et plus l√©gers.
 */

    /**
     * üî∏ Type primitif : int (entier de 32 bits)
     */
    int age = 25;

    /**
     * üî∏ Type primitif : double (nombre √† virgule flottante 64 bits)
     */
    double temperature = 36.6;

    /**
     * üî∏ Type primitif : boolean (vrai ou faux)
     */
    boolean estConnecte = true;

    /**
     * üî∏ Type primitif : char (caract√®re Unicode)
     */
    char initiale = 'A';

    /**
     * üî∏ Type primitif : byte (entier 8 bits)
     */
    byte niveau = 127;

    /**
     * üî∏ Type primitif : short (entier 16 bits)
     */
    short hauteur = 150;

    /**
     * üî∏ Type primitif : long (entier 64 bits)
     */
    long population = 7800000000L;

    /**
     * üî∏ Type primitif : float (nombre √† virgule 32 bits)
     */
    float poids = 72.5f;

    /**
     * üî∏ Type objet : String (cha√Æne de caract√®res, immutable)
     */
    String nom = "Alice";

    /**
     * üî∏ Type objet : ArrayList (liste dynamique)
     */
    ArrayList<String> noms = new ArrayList<>();

    /**
     * üî∏ Type objet : Object (classe m√®re de tous les objets)
     */
    Object o = new Object();

    /**
     * üîπ Exemple de diff√©rence : passage par valeur vs r√©f√©rence
     */
    public void incrementerInt(int n) {
        n++;
        // ne modifie pas la variable originale
    }

    public void ajouterNom(ArrayList<String> liste) {
        liste.add("Paul");
        // modifie la liste originale car c‚Äôest une r√©f√©rence
    }


// =======================================
// üîç [4] CONSTANTES AVEC LE MOT-CLE FINAL
// =======================================

/**
 * üîπ Le mot-cl√© final signifie ¬´ ne peut plus changer ¬ª une fois d√©fini :
 * - Sur une variable ‚Üí emp√™che la r√©affectation
 * - Sur une m√©thode ‚Üí emp√™che la red√©finition (override)
 * - Sur une classe ‚Üí emp√™che l‚Äôh√©ritage
 */

// --------------------------
// üî∏ FINAL sur une VARIABLE
// --------------------------

    /**
     * Constante enti√®re : ne peut √™tre modifi√©e apr√®s l‚Äôinitialisation.
     */
    final int NB_MAX = 100;

    /**
     * Constante avec calcul (possible si affect√©e d√®s la d√©claration)
     */
    final double TAUX_TVA = 0.077;

    /**
     * Une final non initialis√©e doit l‚Äô√™tre dans le constructeur
     */
    final String prenom;

    public MaClasse() {
        this.prenom = "Alice";
        // this.prenom = "Autre"; // ‚ùå Erreur : d√©j√† affect√©
    }

// --------------------------
// üî∏ FINAL sur une M√âTHODE
// --------------------------

    class Animal {

        /**
         * M√©thode finale : ne peut pas √™tre red√©finie par les sous-classes.
         */
        public final void respirer() {
            System.out.println("Je respire !");
        }
    }

    class Chien extends Animal {
        // public void respirer() {} // ‚ùå Erreur : m√©thode finale
    }

// --------------------------
// üî∏ FINAL sur une CLASSE
// --------------------------

    /**
     * Classe finale : ne peut pas √™tre h√©rit√©e.
     */
    final class Utilitaire {
        public static void afficher(String message) {
            System.out.println(message);
        }
    }

// class SousClasse extends Utilitaire {} // ‚ùå Erreur : classe final



// =======================================
// üîç [5] OPERATEURS EN JAVA
// =======================================

/**
 * üîπ Les op√©rateurs permettent d'effectuer des op√©rations sur des variables et des valeurs.
 * Ils sont divis√©s en plusieurs cat√©gories :
 */

// -----------------------------
// üî∏ Op√©rateurs arithm√©tiques
// -----------------------------

    /**
     * Effectue une addition entre deux entiers.
     * @return la somme de a et b
     */
    public int addition(int a, int b) {
        return a + b; // + addition
    }

    /**
     * Effectue une soustraction entre deux entiers.
     */
    int soustraction = 10 - 3; // - soustraction

    /**
     * Effectue une multiplication.
     */
    int produit = 4 * 2; // * multiplication

    /**
     * Effectue une division enti√®re (perd les d√©cimales).
     */
    int division = 10 / 3; // / division

    /**
     * Retourne le reste de la division (modulo).
     */
    int reste = 10 % 3; // % modulo

// -----------------------------
// üî∏ Op√©rateurs d'affectation
// -----------------------------

    /**
     * Affecte une valeur √† une variable.
     */
    int x = 5; // = affectation simple

    /**
     * Incr√©mente la valeur de x de 3.
     */
        x += 3; // √©quivalent √† x = x + 3

    /**
     * D√©cr√©mente la valeur de x de 2.
     */
        x -= 2; // √©quivalent √† x = x - 2

        x *= 4; // x = x * 4
        x /= 2; // x = x / 2
        x %= 3; // x = x % 3

// -----------------------------
// üî∏ Op√©rateurs de comparaison
// -----------------------------

    /**
     * Renvoie true si les deux valeurs sont √©gales.
     */
    boolean estEgal = (a == b);

    /**
     * Renvoie true si les deux valeurs sont diff√©rentes.
     */
    boolean estDiff = (a != b);

    /**
     * Tests d‚Äôordre
     */
    boolean plusGrand = (a > b);
    boolean plusPetit = (a < b);
    boolean auMoins = (a >= b);
    boolean auPlus = (a <= b);

// -----------------------------
// üî∏ Op√©rateurs logiques (bool√©ens)
// -----------------------------

    /**
     * ET logique : true si les deux conditions sont vraies.
     */
    if (a > 5 && b > 5) {}

    /**
     * OU logique : true si au moins une condition est vraie.
     */
    if (a > 5 || b > 5) {}

    /**
     * NON logique : inverse la condition.
     */
    boolean actif = false;
    if (!actif) {
        System.out.println("Inactif");
    }

// -----------------------------
// üî∏ Op√©rateurs d'incr√©mentation / d√©cr√©mentation
// -----------------------------

    int compteur = 0;
    compteur++; // incr√©mente de 1 (post-incr√©mentation)
    ++compteur; // incr√©mente avant d‚Äô√©valuer

    compteur--; // d√©cr√©mente de 1
    --compteur;

// -----------------------------
// üî∏ Op√©rateur ternaire
// -----------------------------

    /**
     * Renvoie "majeur" si l'√¢ge est >= 18, sinon "mineur"
     */
    String statut = (age >= 18) ? "majeur" : "mineur";


// =======================================
// üîç [6] CARACTERES SPECIAUX EN JAVA
// =======================================

    /**
     * üîπ En Java, certains caract√®res ont une signification sp√©ciale lorsqu‚Äôils sont pr√©c√©d√©s par une barre oblique inverse (\\).
     * Ces caract√®res sont appel√©s **caract√®res d‚Äô√©chappement**.
     */

    // -----------------------------
    // üî∏ \n : Saut de ligne
    // -----------------------------

    /**
     * Affiche deux lignes gr√¢ce √† \\n.
     */
    System.out.println("Bonjour\n√† tous");

    /*
      Sortie :
      Bonjour
      √† tous
    */

    // -----------------------------
    // üî∏ \t : Tabulation horizontale
    // -----------------------------

    /**
     * Affiche une tabulation entre deux mots.
     */
    System.out.println("Nom\tPr√©nom");

    /*
      Sortie :
      Nom     Pr√©nom
    */

    // -----------------------------
    // üî∏ \\ : Antislash litt√©ral
    // -----------------------------

    /**
     * Affiche un anti-slash (\\).
     */
    System.out.println("C:\\Users\\Nom");

    /*
      Sortie :
      C:\Users\Nom
    */

    // -----------------------------
    // üî∏ \' : Apostrophe
    // -----------------------------

        /**
         * Affiche une apostrophe dans un caract√®re ou une cha√Æne.
         */
        char apostrophe = '\'';
    System.out.println("C'est l'√©t√© !");

    /*
      Sortie :
      C'est l'√©t√© !
    */

    // -----------------------------
    // üî∏ \" : Guillemet double
    // -----------------------------

    /**
     * Affiche des guillemets dans une cha√Æne.
     */
    System.out.println("Elle a dit : \"Bonjour\"");

    /*
      Sortie :
      Elle a dit : "Bonjour"
    */

    // -----------------------------
    // üî∏ \b : Backspace (efface le caract√®re pr√©c√©dent dans certains contextes console)
    // -----------------------------

    /**
     * Backspace : effet visuel d√©pend du terminal.
     */
    System.out.println("Hello\bWorld"); // Peut afficher "HellWorld" ou "HelWorld"

    /*
      ‚ö†Ô∏è Pas toujours visible selon les IDE/console.
    */


// =======================================
// üîç [7] PORTEE DES VARIABLES EN JAVA
// =======================================

/**
 * üîπ La port√©e (ou ¬´ scope ¬ª) d√©termine o√π une variable est accessible dans le code.
 * Il existe 3 types de port√©e :
 * - Locale
 * - D‚Äôinstance
 * - De classe (statique)
 */

// ---------------------------------
// üî∏ 1. Port√©e locale (variable locale)
// ---------------------------------

    /**
     * Variable locale : d√©clar√©e √† l‚Äôint√©rieur d‚Äôune m√©thode, accessible uniquement dans le bloc.
     */
    public void afficherNom() {
        String nom = "Alice"; // variable locale
        System.out.println(nom);
        // nom existe uniquement ici
    }

// nom = "Bob"; // ‚ùå Erreur : nom n‚Äôexiste pas en dehors du bloc

// ---------------------------------
// üî∏ 2. Port√©e d‚Äôinstance (variable d‚Äôobjet)
// ---------------------------------

    public class Personne {

        /**
         * Variable d‚Äôinstance : propre √† chaque objet.
         */
        private String prenom;

        public Personne(String prenom) {
            this.prenom = prenom; // utilisation via this
        }

        public void afficherPrenom() {
            System.out.println(this.prenom); // accessible dans toute la classe
        }
    }

// ---------------------------------
// üî∏ 3. Port√©e de classe (variable statique)
// ---------------------------------

    public class Compteur {

        /**
         * Variable de classe : partag√©e par toutes les instances.
         * Accessible sans cr√©er d‚Äôobjet.
         */
        public static int nbInstances = 0;

        public Compteur() {
            nbInstances++; // on incr√©mente le compteur global
        }

        public static void afficherNbInstances() {
            System.out.println("Total : " + nbInstances);
        }
    }


// =======================================
// üîç [8] SYSTEM.OUT.PRINTLN
// =======================================
    System.out.println("Bonjour");


// =======================================
// üîç [9] DECLARATION ET INSTANTIATION D‚ÄôOBJETS
// =======================================

/**
 * üîπ D√©clarer un objet = cr√©er une r√©f√©rence vers un type
 * üîπ Instancier un objet = r√©server de la m√©moire avec le mot-cl√© `new`
 * üîπ Une fois instanci√©, on peut acc√©der aux m√©thodes/attributs via `.`
 */

// ---------------------------------------
// üî∏ Exemple 1 : d√©claration + instanciation
// ---------------------------------------

    /**
     * On cr√©e une instance de la classe Personne.
     */
    Personne p = new Personne("Alice");

    /**
     * On appelle une m√©thode sur l‚Äôinstance.
     */
    p.afficherNom();

    /**
     * On peut aussi s√©parer d√©claration et instanciation.
     */
    Personne p2;             // d√©claration
    p2 = new Personne("Bob"); // instanciation

// ---------------------------------------
// üî∏ Exemple 2 : tableau ou liste d‚Äôobjets
// ---------------------------------------

    /**
     * Tableau de 3 objets Personne.
     */
    Personne[] tab = new Personne[3];
    tab[0] = new Personne("Claire");
    tab[1] = new Personne("David");
    tab[2] = new Personne("Emma");

    /**
     * Liste dynamique d‚Äôobjets Personne (ArrayList).
     */
    ArrayList<Personne> personnes = new ArrayList<>();
    personnes.add(new Personne("L√©o"));
    personnes.add(new Personne("Nina"));

    /**
     * Parcours avec une boucle foreach.
     */
    for (Personne pers : personnes) {
            pers.afficherNom();
        }

// ---------------------------------------
// üî∏ Exemple 3 : objet avec plusieurs attributs
// ---------------------------------------

    /**
     * Instanciation avec plusieurs param√®tres dans le constructeur.
     */
    Voiture v = new Voiture("Renault", "Clio", 2020);
    v.afficherInfos();

    /**
     * Utilisation d‚Äôun objet instanci√© comme param√®tre d‚Äôune m√©thode.
     */
    Garage garage = new Garage();
    garage.entreeVehicule(v);


// =======================================
// üîç [10] MODIFICATEURS EN JAVA
// =======================================

/**
 * üîπ Les modificateurs permettent de d√©finir :
 * - La **visibilit√©** d‚Äôun membre (classe, attribut, m√©thode)
 * - Son **comportement** (immuable, partag√©, abstrait, etc.)
 */

// -------------------------------------------------
// üî∏ 1. Modificateurs d'acc√®s : private, public, protected
// -------------------------------------------------

    /**
     * Attribut priv√© ‚Üí accessible uniquement dans la classe.
     */
    private int age;

    /**
     * M√©thode publique ‚Üí accessible depuis partout.
     */
    public void saluer() {
        System.out.println("Bonjour !");
    }

    /**
     * Attribut prot√©g√© ‚Üí accessible dans la classe et ses sous-classes.
     */
    protected String nom;

    /**
     * Acc√®s par niveau :
     * - private : classe uniquement
     * - default (aucun mot-cl√©) : package
     * - protected : package + h√©ritage
     * - public : accessible partout
     */

// -------------------------------------------------
// üî∏ 2. static : Appartient √† la classe
// -------------------------------------------------

    /**
     * Attribut static : partag√© entre toutes les instances.
     */
    public static int compteur = 0;

    /**
     * M√©thode statique : peut √™tre appel√©e sans objet.
     */
    public static void afficherCompteur() {
        System.out.println("Compteur = " + compteur);
    }

    /**
     * Utilisation :
     * Classe.methodeStatique();
     * Exemple :
     */
    Math.sqrt(16); // appel statique

// -------------------------------------------------
// üî∏ 3. final : Interdiction de modification
// -------------------------------------------------

    /**
     * Variable finale : constante.
     */
    final double TAUX_TVA = 0.077;

    /**
     * M√©thode finale : ne peut pas √™tre red√©finie dans une sous-classe.
     */
    public final void respirer() {
        System.out.println("Je respire");
    }

    /**
     * Classe finale : ne peut pas √™tre h√©rit√©e.
     */
    final class Utilitaire {
        // code ici
    }

// -------------------------------------------------
// üî∏ 4. abstract : Obligation d‚Äôimpl√©menter
// -------------------------------------------------

    /**
     * Classe abstraite : ne peut pas √™tre instanci√©e.
     */
    abstract class Animal {
        /**
         * M√©thode abstraite : sans corps, √† impl√©menter dans les sous-classes.
         */
        public abstract void crier();

        /**
         * M√©thode concr√®te : peut √™tre utilis√©e telle quelle.
         */
        public void manger() {
            System.out.println("L‚Äôanimal mange");
        }
    }

    /**
     * Classe concr√®te qui h√©rite et impl√©mente la m√©thode.
     */
    class Chat extends Animal {
        @Override
        public void crier() {
            System.out.println("Miaou");
        }
    }

// -------------------------------------------------
// üî∏ 5. void : M√©thode ne retournant rien
// -------------------------------------------------

    /**
     * M√©thode void : ex√©cute une action sans retourner de r√©sultat.
     */
    public void afficherBonjour() {
        System.out.println("Bonjour !");
    }

    /**
     * M√©thode non-void (avec return)
     */
    public int doubler(int n) {
        return n * 2;
    }


// =======================================
// üîç [11] CONDITIONS
// =======================================

/**
 * if : ex√©cute un bloc si la condition est vraie
 * else if : ajoute une condition interm√©diaire
 * else : ex√©cute si aucune condition n‚Äôest remplie
 */

    if (age >= 65) {
        System.out.println("Senior");
    } else if (age >= 18) {
        System.out.println("Majeur");
    } else {
        System.out.println("Mineur");
    }


// =======================================
// üîç [12] BOUCLES EN JAVA
// =======================================

/**
 * üîπ Les boucles permettent d'ex√©cuter un bloc d'instructions plusieurs fois.
 * Java en propose trois types principaux :
 * - for : boucle avec compteur
 * - while : tant que la condition est vraie
 * - do...while : au moins une ex√©cution
 */

// ------------------------------------
// üî∏ 1. Boucle for
// ------------------------------------

    /**
     * Boucle for classique : de 0 √† 4
     */
    for (int i = 0; i < 5; i++) {
            System.out.println("i = " + i);
        }

    /**
     * Boucle for √† rebours
     */
    for (int i = 10; i > 0; i--) {
            System.out.println(i);
        }

// ------------------------------------
// üî∏ 2. Boucle while
// ------------------------------------

    /**
     * Boucle while : s‚Äôex√©cute tant que la condition est vraie
     */
    int compteur = 0;
    while (compteur < 3) {
            System.out.println("compteur = " + compteur);
            compteur++;
        }

    /**
     * Exemple de boucle while infinie (√† √©viter sans condition d‚Äôarr√™t)
     */
    // while (true) {
    //     System.out.println("Boucle infinie");
    // }

// ------------------------------------
// üî∏ 3. Boucle do...while
// ------------------------------------

    /**
     * Boucle do...while : s‚Äôex√©cute au moins une fois
     */
    int choix;
    do {
        choix = scanner.nextInt(); // n√©cessite un Scanner
        System.out.println("Tu as choisi : " + choix);
    } while (choix != 0);


// =======================================
// üîç [13] METHODES & PARAMETRES
// =======================================

/**
 * üîπ Une m√©thode est un bloc de code nomm√© qui peut :
 * - Recevoir des param√®tres
 * - Retourner une valeur (ou pas, avec void)
 * - √ätre appel√©e plusieurs fois
 */

// -------------------------------------------
// üî∏ M√©thode SANS param√®tre, SANS retour
// -------------------------------------------

    /**
     * Affiche un message de bienvenue.
     */
    public void afficherBienvenue() {
        System.out.println("Bienvenue !");
    }

// -------------------------------------------
// üî∏ M√©thode AVEC param√®tre, SANS retour
// -------------------------------------------

    /**
     * Affiche le pr√©nom donn√© en param√®tre.
     * @param prenom Le pr√©nom √† afficher
     */
    public void afficherPrenom(String prenom) {
        System.out.println("Bonjour " + prenom);
    }

// -------------------------------------------
// üî∏ M√©thode AVEC param√®tre, AVEC retour
// -------------------------------------------

    /**
     * Additionne deux entiers.
     * @param a premier entier
     * @param b deuxi√®me entier
     * @return la somme des deux entiers
     */
    public int addition(int a, int b) {
        return a + b;
    }

// -------------------------------------------
// üî∏ M√©thode SANS param√®tre, AVEC retour
// -------------------------------------------

    /**
     * Retourne un nombre al√©atoire entre 0 et 9.
     * @return entier al√©atoire
     */
    public int genererAleatoire() {
        Random r = new Random();
        return r.nextInt(10);
    }

// -------------------------------------------
// üî∏ Appel de m√©thode (dans main ou ailleurs)
// -------------------------------------------

    /**
     * Exemple d'appel dans le main :
     */
    public static void main(String[] args) {
        afficherBienvenue();            // sans param√®tre
        afficherPrenom("Alice");        // avec param√®tre
        int res = addition(5, 3);       // r√©cup√©ration de retour
        System.out.println(res);
    }


// =======================================
// üîç [14] PASSAGE PAR VALEUR VS PAR REFERENCE
// =======================================

/**
 * üîπ En Java, tout est pass√© par **valeur**.
 * Mais :
 * - Pour les **types primitifs**, la valeur elle-m√™me est copi√©e.
 * - Pour les **objets**, c‚Äôest la **r√©f√©rence** qui est copi√©e ‚Üí l‚Äôobjet point√© peut √™tre modifi√©.
 */

// ---------------------------------------------------
// üî∏ Exemple 1 : Passage d‚Äôun type primitif (int)
// ---------------------------------------------------

    /**
     * Cette m√©thode tente d‚Äôincr√©menter un entier.
     * @param x une copie de la valeur d‚Äôorigine
     */
    public void incrementer(int x) {
        x++;
        System.out.println("Dans la m√©thode : x = " + x);
    }

    int a = 5;
    incrementer(a);
    System.out.println("Apr√®s m√©thode : a = " + a);  // reste 5

    // R√©sultat : l‚Äôoriginal n‚Äôest PAS modifi√©

// ---------------------------------------------------
// üî∏ Exemple 2 : Passage d‚Äôun objet (ArrayList)
// ---------------------------------------------------

    /**
     * Cette m√©thode modifie une liste d‚Äôentiers.
     * @param liste une copie de la r√©f√©rence vers la liste
     */
    public void ajouterValeur(ArrayList<Integer> liste) {
        liste.add(42);
    }

    ArrayList<Integer> maListe = new ArrayList<>();
    ajouterValeur(maListe);
    System.out.println(maListe);  // contient [42]

    // R√©sultat : l‚Äôobjet original EST modifi√©

// ---------------------------------------------------
// üî∏ Exemple 3 : R√©assignation d‚Äôune r√©f√©rence
// ---------------------------------------------------

    /**
     * Cette m√©thode r√©affecte une nouvelle liste √† la r√©f√©rence.
     */
    public void remplacerListe(ArrayList<String> liste) {
        liste = new ArrayList<>(); // ‚ö†Ô∏è redirection, ne modifie pas l‚Äôoriginal
        liste.add("Hello");
    }

    ArrayList<String> noms = new ArrayList<>();
    noms.add("Jean");
    remplacerListe(noms);
    System.out.println


// =======================================
// üîç [15] METHODE MAIN
// =======================================
    public static void main(String[] args) {}

// =======================================
// üîç [16] GETTERS & SETTERS
// =======================================
    public String getNom() { return nom; }
    public void setNom(String nom) { this.nom = nom; }

// =======================================
// üîç [17] CONSTRUCTEURS EN JAVA
// =======================================

    /**
     * üîπ Un constructeur est une m√©thode sp√©ciale appel√©e lors de l‚Äôinstanciation d‚Äôun objet.
     * - Il porte le **m√™me nom** que la classe.
     * - Il n‚Äôa **pas de type de retour**.
     * - On peut en d√©finir **plusieurs** ‚Üí c‚Äôest la **surcharge de constructeur**.
     */

    public class Personne {
        private String nom;
        private int age;

        /**
         * üî∏ Constructeur 1 : avec nom + √¢ge
         * @param nom le nom de la personne
         * @param age l'√¢ge de la personne
         */
        public Personne(String nom, int age) {
            this.nom = nom;
            this.age = age;
        }

        /**
         * üî∏ Constructeur 2 : avec seulement le nom
         * L'√¢ge sera d√©fini par d√©faut √† 0.
         */
        public Personne(String nom) {
            this(nom, 0); // appel de l‚Äôautre constructeur
        }

        /**
         * üî∏ Constructeur 3 : sans param√®tre
         * Affecte des valeurs par d√©faut.
         */
        public Personne() {
            this("Inconnu", 0);
        }

        /**
         * Affiche les infos de la personne.
         */
        public void afficher() {
            System.out.println("Nom : " + nom + " | √Çge : " + age);
        }
    }


// =======================================
// üîç [18] METHODES GENERALES UTILES
// =======================================

    /**
     * V√©rifie si un nombre est pair.
     * @param n entier √† tester
     * @return true si pair, false sinon
     */
    public boolean estPair(int n) {
        return n % 2 == 0;
    }

    /**
     * V√©rifie si un nombre est premier.
     * @param n entier √† tester
     * @return true si nombre premier
     */
    public boolean estPremier(int n) {
        if (n <= 1) return false;
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (n % i == 0) return false;
        }
        return true;
    }

    /**
     * Retourne le maximum entre deux entiers.
     * @param a premier entier
     * @param b second entier
     * @return le plus grand des deux
     */
    public int max(int a, int b) {
        return (a > b) ? a : b;
    }

    /**
     * Retourne la moyenne d‚Äôun tableau d‚Äôentiers.
     * @param tab tableau d'entiers
     * @return moyenne (double)
     */
    public double moyenne(int[] tab) {
        if (tab.length == 0) return 0;
        int somme = 0;
        for (int n : tab) somme += n;
        return (double) somme / tab.length;
    }

    /**
     * Inverse une cha√Æne de caract√®res.
     * @param texte cha√Æne d'entr√©e
     * @return cha√Æne invers√©e
     */
    public String inverser(String texte) {
        return new StringBuilder(texte).reverse().toString();
    }

    /**
     * Calcule la somme des √©l√©ments d'une liste d'entiers.
     * @param liste liste d'entiers
     * @return somme totale
     */
    public int sommeListe(ArrayList<Integer> liste) {
        int somme = 0;
        for (int n : liste) somme += n;
        return somme;
    }

    /**
     * Compte le nombre d'occurrences d'un caract√®re dans une cha√Æne.
     * @param phrase la phrase √† analyser
     * @param c caract√®re √† compter
     * @return nombre d‚Äôoccurrences
     */
    public int compterOccurrences(String phrase, char c) {
        int compteur = 0;
        for (int i = 0; i < phrase.length(); i++) {
            if (phrase.charAt(i) == c) compteur++;
        }
        return compteur;
    }

    /**
     * V√©rifie si une liste contient un √©l√©ment donn√©.
     * @param liste liste √† parcourir
     * @param valeur √©l√©ment √† chercher
     * @return true si pr√©sent, false sinon
     */
    public boolean contient(ArrayList<String> liste, String valeur) {
        return liste.contains(valeur);
    }


// =======================================
// üîç [19] METHODES UTILISEES FREQUEMMENT (complement)
// =======================================

/**
 * üîπ M√©thodes classiques et souvent utilis√©es dans les TP/examens
 * qui ne figurent pas d√©j√† dans la section [18].
 */

// ----------------------------------------------------
// afficherListe : affiche chaque √©l√©ment d'une liste
// ----------------------------------------------------

    /**
     * Affiche tous les √©l√©ments d‚Äôune liste de cha√Ænes.
     * @param liste la liste √† parcourir
     */
    public void afficherListe(ArrayList<String> liste) {
        for (String e : liste) {
            System.out.println(e);
        }
    }

// ----------------------------------------------------
// max : retourne le maximum entre deux doubles
// ----------------------------------------------------

    /**
     * Renvoie le maximum entre deux doubles.
     * @param x premi√®re valeur
     * @param y deuxi√®me valeur
     * @return la plus grande des deux
     */
    public double max(double x, double y) {
        return (x > y) ? x : y;
    }

// ----------------------------------------------------
// min : retourne le plus petit entier d‚Äôun tableau
// ----------------------------------------------------

    /**
     * Renvoie le plus petit entier dans un tableau.
     * @param tab tableau d‚Äôentiers
     * @return minimum du tableau
     */
    public int min(int[] tab) {
        int min = tab[0];
        for (int i = 1; i < tab.length; i++) {
            if (tab[i] < min) min = tab[i];
        }
        return min;
    }

// ----------------------------------------------------
// copierListe : cr√©e une copie d‚Äôune liste
// ----------------------------------------------------

    /**
     * Copie les √©l√©ments d‚Äôune liste dans une nouvelle liste.
     * @param origine liste source
     * @return nouvelle liste contenant les m√™mes √©l√©ments
     */
    public ArrayList<String> copierListe(ArrayList<String> origine) {
        return new ArrayList<>(origine);
    }


// =======================================
// üîç [20] JAVADOC
// =======================================
/**
 * üîπ COMMENTAIRE JAVADOC
 * Utilis√© pour documenter des classes, attributs ou m√©thodes.
 * G√©n√®re automatiquement de la documentation HTML avec javadoc.
 * Commence par /** et se termine par *\/
 * Exemple : voir les m√©thodes ci-dessous.
 */

    /**
     * Cette m√©thode retourne l'√¢ge d'un utilisateur.
     * @return int : √¢ge
     */
    public int getAge() {
        return this.age;
    }

    /**
     * Cette m√©thode d√©finit le pr√©nom d‚Äôun utilisateur.
     * @param prenom Le pr√©nom √† attribuer √† l‚Äôutilisateur
     */
    public void setPrenom(String prenom) {
        this.prenom = prenom;
    }

    /**
     * Cette m√©thode affiche un message de bienvenue dans la console.
     */
    public void afficherBienvenue() {
        System.out.println("Bienvenue !");
    }

    /**
     * Calcule la somme de deux entiers.
     * @param a premier entier
     * @param b deuxi√®me entier
     * @return int : la somme des deux entiers
     */
    public int somme(int a, int b) {
        return a + b;
    }

// =======================================
// üîç [21] TABLEAUX (1 dimension)
// =======================================

/**
 * üîπ Un tableau est une structure fixe qui contient des √©l√©ments de m√™me type.
 * üîπ On y acc√®de via des indices commen√ßant √† 0.
 */

    /**
     * D√©claration + initialisation directe
     */
    int[] t = {1, 2, 3};

    /**
     * D√©claration + allocation
     */
    int[] notes = new int[5]; // 5 cases initialis√©es √† 0

    /**
     * Affectation d‚Äôune valeur
     */
        notes[0] = 15;

    /**
     * Parcours avec boucle for
     */
    for (int i = 0; i < notes.length; i++) {
        System.out.println("notes[" + i + "] = " + notes[i]);
    }

    /**
     * Parcours avec foreach
     */
    for (int n : notes) {
        System.out.println(n);
    }

    /**
     * Longueur d‚Äôun tableau
     */
    int taille = notes.length;

    /**
     * Copier un tableau (manuel)
     */
    int[] copie = new int[notes.length];
    for (int i = 0; i < notes.length; i++) {
        copie[i] = notes[i];
    }


// =======================================
// üîç [22] MATRICES (tableaux √† 2 dimensions)
// =======================================

/**
 * üîπ Une matrice est un tableau de tableaux (2 dimensions)
 * üîπ Utilis√© pour repr√©senter des grilles, tableaux num√©riques, etc.
 */

    /**
     * D√©claration + allocation 3x3
     */
    int[][] m = new int[3][3]; // matrice de 3 lignes, 3 colonnes

    /**
     * Initialisation manuelle
     */
    m[0][0] = 1;
    m[1][2] = 5;

    /**
     * Parcours avec deux boucles for
     */
    for (int i = 0; i < m.length; i++) {
        for (int j = 0; j < m[i].length; j++) {
            System.out.print(m[i][j] + " ");
        }
        System.out.println();
    }

    /**
     * Initialisation directe
     */
    int[][] matrice = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    /**
     * Affichage avec foreach
     */
    for (int[] ligne : matrice) {
        for (int valeur : ligne) {
            System.out.print(valeur + " ");
        }
        System.out.println();
    }


// =======================================
// üîç [23] LISTES DYNAMIQUES : ARRAYLIST, LINKEDLIST, VECTOR
// =======================================

/**
 * üîπ Les listes dynamiques permettent :
 * - d‚Äôajouter ou retirer des √©l√©ments √† la vol√©e
 * - d‚Äôadapter leur taille automatiquement
 * - d‚Äôacc√©der aux √©l√©ments via un index (comme un tableau)
 *
 * Java propose 3 principales impl√©mentations :
 * - ArrayList : rapide pour l'acc√®s par index
 * - LinkedList : rapide pour les ajouts/suppressions en milieu de liste
 * - Vector : version synchronis√©e (thread-safe) d'ArrayList
 */

// ----------------------------------------------------
// üî∏ ArrayList
// ----------------------------------------------------

    /**
     * Liste de cha√Ænes initialis√©e vide
     */
    ArrayList<String> noms = new ArrayList<>();

    noms.add("Alice");
    noms.add("Bob");
    noms.get(1);            // "Bob"
    noms.remove("Alice");   // supprime "Alice"
    noms.size();            // retourne 1

// ----------------------------------------------------
// üî∏ LinkedList
// ----------------------------------------------------

    /**
     * Liste doublement cha√Æn√©e, optimis√©e pour ajouts/suppressions
     */
    LinkedList<String> file = new LinkedList<>();

    file.add("T√¢che1");
    file.addFirst("Urgent");
    file.addLast("Optionnel");
    file.removeLast();      // supprime le dernier √©l√©ment

// ----------------------------------------------------
// üî∏ Vector
// ----------------------------------------------------

    /**
     * Liste synchronis√©e, peu utilis√©e sauf en multithreading
     */
    Vector<Integer> scores = new Vector<>();

    scores.add(10);
    scores.add(20);
    scores.set(0, 15);       // remplace la valeur √† l‚Äôindex 0

// ----------------------------------------------------
// üî∏ M√©thodes communes utiles
// ----------------------------------------------------

    /**
     * M√©thodes partag√©es par ArrayList, LinkedList, Vector :
     * - add(element)              ‚Üí ajoute √† la fin
     * - add(index, element)       ‚Üí ins√®re √† l‚Äôindex donn√©
     * - get(index)                ‚Üí r√©cup√®re un √©l√©ment
     * - remove(index/element)     ‚Üí supprime un √©l√©ment
     * - contains(element)         ‚Üí v√©rifie la pr√©sence
     * - size()                    ‚Üí retourne le nombre d‚Äô√©l√©ments
     * - isEmpty()                 ‚Üí true si vide
     * - clear()                   ‚Üí vide la liste
     */


// =======================================
// üîç [24] DICTIONNAIRE : HASHMAP
// =======================================

/**
 * üîπ Une HashMap permet d‚Äôassocier des cl√©s √† des valeurs (structure cl√© ‚Üí valeur).
 * - Les cl√©s doivent √™tre uniques
 * - Les valeurs peuvent √™tre dupliqu√©es
 * - Acc√®s rapide par cl√©
 *
 * Syntaxe : HashMap<Cl√©, Valeur> map = new HashMap<>();
 */

    import java.util.HashMap;

    HashMap<String, Integer> notes = new HashMap<>();

    /**
     * put(K, V) : ajoute ou remplace une paire cl√©/valeur
     */
    notes.put("Alice", 15);
    notes.put("Bob", 12);
    notes.put("Alice", 18); // Remplace 15 par 18

    /**
     * get(K) : retourne la valeur associ√©e √† la cl√©
     */
    int noteAlice = notes.get("Alice"); // 18

    /**
     * containsKey(K) : retourne true si la cl√© existe
     */
    boolean aBob = notes.containsKey("Bob"); // true

    /**
     * remove(K) : supprime la paire pour la cl√© donn√©e
     */
    notes.remove("Bob");

    /**
     * keySet() : retourne un Set contenant toutes les cl√©s
     */
    for (String nom : notes.keySet()) {
        System.out.println(nom + " ‚Üí " + notes.get(nom));
    }

//Exemple de parcours avec for
    Map myMap = new HashMap();
    for (String cle : myMap.keySet()){
        Object valeur = myMap.get(cle);
    }

    /**
     * values() : retourne une Collection contenant toutes les valeurs
     */
    for (int valeur : notes.values()) {
        System.out.println(valeur);
    }

    /**
     * size() : nombre de paires dans la map
     */
    int nbElements = notes.size();

    /**
     * isEmpty() : true si la map est vide
     */
    boolean estVide = notes.isEmpty();


// =======================================
// üîç [25] ITERATOR
// =======================================

/**
 * üîπ Un Iterator permet de parcourir une collection de mani√®re uniforme
 * sans d√©pendre de la structure utilis√©e (ArrayList, HashSet, etc.).
 *
 * üî∏ M√©thodes principales :
 * - hasNext() : y a-t-il un √©l√©ment suivant ?
 * - next() : retourne l‚Äô√©l√©ment suivant
 * - remove() : supprime l‚Äô√©l√©ment courant (optionnel)
 *
 * ‚ö†Ô∏è Ne jamais modifier une collection avec add/remove pendant l'it√©ration sauf via l'iterator lui-m√™me.
 */

    import java.util.Iterator;
    import java.util.ArrayList;
    import java.util.HashSet;

// ------------------------------------------------------------
// üî∏ Exemple avec ArrayList
// ------------------------------------------------------------

    ArrayList<String> noms = new ArrayList<>();
    noms.add("Alice");
    noms.add("Bob");
    noms.add("Claire");

    Iterator<String> it = noms.iterator();

    /**
     * Parcours avec iterator
     */
    while (it.hasNext()) {
        String nom = it.next();
        System.out.println(nom);

        // Supprimer un nom pr√©cis (correct)
        if (nom.equals("Bob")) {
            it.remove(); // autoris√© ici
        }
    }

// ------------------------------------------------------------
// üî∏ Exemple avec HashSet
// ------------------------------------------------------------

    HashSet<Integer> valeurs = new HashSet<>();
    valeurs.add(10);
    valeurs.add(20);
    valeurs.add(30);

    Iterator<Integer> iter = valeurs.iterator();

    /**
     * Parcours et suppression s√©curis√©e d‚Äô√©l√©ments < 25
     */
    while (iter.hasNext()) {
        int val = iter.next();
        if (val < 25) {
            iter.remove();
        }
    }


// =======================================
// üîç [26] ENSEMBLES (SET) : HASHSET, TREESET
// =======================================

    import java.util.HashSet;
    import java.util.TreeSet;

    /**
     * üîπ Un Set est une collection sans doublons.
     * üî∏ Deux types principaux :
     * - HashSet : rapide, ordre non garanti
     * - TreeSet : tri√© automatiquement (ordre naturel ou avec Comparator)
     */

// ----------------------------------------
// üî∏ HashSet : ensemble non tri√©
// ----------------------------------------

    HashSet<String> couleurs = new HashSet<>();
    couleurs.add("Rouge");
    couleurs.add("Vert");
    couleurs.add("Bleu");
    couleurs.add("Rouge"); // ignor√© (d√©j√† pr√©sent)

    /**
     * Affiche toutes les couleurs (ordre non garanti)
     */
    for (String c : couleurs) {
        System.out.println(c);
    }

// ----------------------------------------
// üî∏ TreeSet : ensemble tri√© automatiquement
// ----------------------------------------

    TreeSet<Integer> nombres = new TreeSet<>();
    nombres.add(50);
    nombres.add(20);
    nombres.add(80);

    /**
     * Affiche les valeurs dans l‚Äôordre : 20, 50, 80
     */
    for (int n : nombres) {
        System.out.println(n);
    }

// ----------------------------------------
// üî∏ M√©thodes utiles communes √† tous les Set
// ----------------------------------------

    /**
     * - add(obj)        ‚Üí ajoute un √©l√©ment (si absent)
     * - remove(obj)     ‚Üí supprime un √©l√©ment
     * - contains(obj)   ‚Üí teste la pr√©sence d‚Äôun √©l√©ment
     * - size()          ‚Üí retourne le nombre d‚Äô√©l√©ments
     * - isEmpty()       ‚Üí true si le Set est vide
     * - clear()         ‚Üí vide compl√®tement le Set
     * - iterator()      ‚Üí permet un parcours personnalis√© (voir point [25])
     */


// =======================================
// üîç [27] OBJETS & APPELS
// =======================================

    /**
     * üîπ Cr√©ation d‚Äôun objet
     */
    Personne p = new Personne("Alice");

    /**
     * üîπ Appel de m√©thode de l‚Äôobjet
     */
    p.afficher();

    /**
     * üîπ Appel d‚Äôun getter pour acc√©der √† une valeur
     */
    String nom = p.getNom();

    /**
     * üîπ Passage d‚Äôun objet en param√®tre
     */
    public void saluer(Personne pers) {
        System.out.println("Bonjour " + pers.getNom());
    }


// =======================================
// üîç [28] ABSTRACTION & MODULARISATION
// =======================================

/**
 * üîπ ABSTRACTION
 * L‚Äôabstraction consiste √† cacher les d√©tails d‚Äôimpl√©mentation et √† ne montrer que l‚Äôessentiel.
 * On se concentre sur "ce que fait" un objet, et non sur "comment il le fait".
 *
 * En Java, cela se fait via :
 * - Classes abstraites (`abstract class`)
 * - Interfaces
 * - Encapsulation (utilisation des getters/setters au lieu d‚Äôun acc√®s direct)
 */

// ------------------------------------------------------------
// üî∏ Exemple : classe abstraite
// ------------------------------------------------------------

    /**
     * Classe abstraite : on ne peut pas l‚Äôinstancier directement.
     */
    public abstract class Animal {

        /**
         * M√©thode abstraite : doit √™tre impl√©ment√©e par les sous-classes
         */
        public abstract void crier();

        /**
         * M√©thode concr√®te : d√©j√† d√©finie
         */
        public void manger() {
            System.out.println("Je mange");
        }
    }

    public class Chien extends Animal {
        @Override
        public void crier() {
            System.out.println("Wouf !");
        }
    }

// ------------------------------------------------------------
// üîπ MODULARISATION
// ------------------------------------------------------------

    /**
     * üîπ La modularisation consiste √† :
     * - D√©couper un programme en **unit√©s logiques r√©utilisables**
     * - Favoriser la **lisibilit√©, maintenance, et r√©utilisabilit√©**
     *
     * Chaque classe, chaque m√©thode devrait avoir **une responsabilit√© claire**.
     */

    // Exemple de bonne modularisation :
    // Classe Chien ‚Üí donn√©es et comportements li√©s √† un chien
    // Classe Veterinaire ‚Üí actions de soins sur un animal
    // Classe Application ‚Üí contient juste le `main`

// ------------------------------------------------------------
// üî∏ Illustration : s√©paration logique des responsabilit√©s
// ------------------------------------------------------------

    /**
     * G√®re les donn√©es d‚Äôun animal
     */
    public class Animal {
        private String nom;

        public Animal(String nom) {
            this.nom = nom;
        }

        public String getNom() {
            return nom;
        }
    }

    /**
     * G√®re les traitements sur l‚Äôanimal (soins, nourriture, etc.)
     */
    public class Veterinaire {
        public void nourrir(Animal a) {
            System.out.println(a.getNom() + " est nourri.");
        }
    }

    /**
     * G√®re l‚Äôex√©cution principale du programme
     */
    public class Application {
        public static void main(String[] args) {
            Animal chat = new Animal("Miaou");
            Veterinaire vet = new Veterinaire();
            vet.nourrir(chat);
        }
    }


// =======================================
// üîç [29] HERITAGE, INTERFACES & POLYMORPHISME
// =======================================

/**
 * Cette section couvre les fondements de l‚Äôorient√© objet en Java :
 * - L‚Äôh√©ritage (extends)
 * - L‚Äôappel de super()
 * - Les niveaux de visibilit√©
 * - L‚Äôabstraction et les interfaces
 * - Le polymorphisme (type statique vs dynamique)
 * - override / overloading
 */

// --------------------------------------
// üî∏ 29.1 extends, superclasse, sous-classes
// --------------------------------------

    /**
     * Une sous-classe h√©rite d‚Äôune superclasse avec `extends`
     */
    class Vehicule {
        public void demarrer() {
            System.out.println("D√©marrage g√©n√©rique");
        }
    }

    class Voiture extends Vehicule {
        public void klaxonner() {
            System.out.println("Bip bip !");
        }
    }

// --------------------------------------
// üî∏ 29.2 constructeurs avec super()
// --------------------------------------

    /**
     * La premi√®re ligne du constructeur d‚Äôune sous-classe peut appeler le constructeur parent.
     */
    class Animal {
        public Animal(String nom) {
            System.out.println("Animal cr√©√© : " + nom);
        }
    }

    class Chat extends Animal {
        public Chat() {
            super("Chat"); // appel au constructeur parent
        }
    }

// --------------------------------------
// üî∏ 29.3 droits d‚Äôacc√®s : private, protected, public
// --------------------------------------

    /**
     * private     ‚Üí uniquement dans la classe
     * protected   ‚Üí dans le package + les sous-classes
     * public      ‚Üí accessible partout
     */

    class Exemple {
        private int a;        // visible dans Exemple seulement
        protected int b;      // visible dans les sous-classes
        public int c;         // visible partout
    }

// --------------------------------------
// üî∏ 29.4 classes abstraites & m√©thodes concr√®tes
// --------------------------------------

    abstract class Canin {
        /**
         * M√©thode concr√®te
         */
        public void bouger() {
            System.out.println("Je me d√©place");
        }

        /**
         * M√©thode abstraite √† impl√©menter
         */
        public abstract void crier();
    }

    class Loup extends Canin {
        @Override
        public void crier() {
            System.out.println("Ahouuu !");
        }
    }

// --------------------------------------
// üî∏ 29.5 Interface ICallable : constante, getNom(), setNom()
// --------------------------------------

    interface ICallable {
        String NOM_PAR_DEFAUT = ""; // constante publique statique implicite

        String getNom();    // m√©thode abstraite
        void setNom(String nom);
    }

    class Chien implements ICallable {
        private String nom;

        public String getNom() {
            return ICallable.NOM_PAR_DEFAUT + this.nom;
        }

        public void setNom(String nom) {
            this.nom = nom;
        }
    }

// --------------------------------------
// üî∏ 29.6 Type statique vs type dynamique
// --------------------------------------

    /**
     * Type statique : connu √† la compilation (d√©claration)
     * Type dynamique : le type r√©el de l'objet √† l'ex√©cution
     */
    Canin c1 = new Loup();   // statique = Canin, dynamique = Loup
    c1.crier();              // Appelle la m√©thode de Loup (runtime)

// --------------------------------------
// üî∏ 29.7 override vs overloading
// --------------------------------------

    /**
     * Override : red√©finir une m√©thode h√©rit√©e
     */
    class Animal {
        public void parler() {
            System.out.println("...");
        }
    }

    class Oiseau extends Animal {
        @Override
        public void parler() {
            System.out.println("Cui cui !");
        }
    }

    /**
     * Overloading : plusieurs m√©thodes avec le m√™me nom mais des param√®tres diff√©rents
     */
    class Calculatrice {
        public int addition(int a, int b) {
            return a + b;
        }

        public double addition(double a, double b) {
            return a + b;
        }
    }

// --------------------------------------
// üî∏ 29.8 Comparable, Comparator, equals & hashCode
// --------------------------------------

    /**
     * üîπ Comparable : d√©finit un ordre naturel d'une classe.
     * - Impl√©mente la m√©thode compareTo()
     * - Utilis√© par Collections.sort(liste)
     */

    class Personne implements Comparable<Personne> {
        private String nom;

        public Personne(String nom) {
            this.nom = nom;
        }

        public String getNom() {
            return nom;
        }

        @Override
        public int compareTo(Personne autre) {
            return this.nom.compareTo(autre.nom); // ordre alphab√©tique
        }
    }

    /**
     * üîπ Comparator : permet de trier autrement que par l‚Äôordre naturel
     * - Impl√©mente la m√©thode compare()
     * - S'utilise avec Collections.sort(liste, comparator)
     */

    import java.util.Comparator;

    class ComparateurParLongueur implements Comparator<Personne> {
        @Override
        public int compare(Personne p1, Personne p2) {
            return Integer.compare(p1.getNom().length(), p2.getNom().length());
        }
    }

    /**
     * üîπ equals() : comparaison de contenu logique entre objets
     * üîπ hashCode() : utilis√© pour placer/trouver les objets dans les collections de type Hash (HashMap, HashSet‚Ä¶)
     *
     * ‚ö†Ô∏è Si deux objets sont √©gaux selon equals(), ils doivent avoir le m√™me hashCode().
     */

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Personne)) return false;
        Personne personne = (Personne) o;
        return nom.equals(personne.nom);
    }

    @Override
    public int hashCode() {
        return nom.hashCode(); // ou Objects.hash(nom);
    }


// =======================================
// üîç [30] CARTES CRC
// =======================================

    /**
     * üîπ Les cartes CRC (Classe - Responsabilit√© - Collaboration) servent √† mod√©liser :
     * - Quelle est la responsabilit√© d'une classe ?
     * - Avec quelles autres classes elle interagit ?
     *
     * üî∏ Ce sont des outils de conception orient√©e objet utilis√©s avant l‚Äô√©criture du code.
     */

    // üß© Exemple : mod√®le Client - Commande

    // -----------------------------------------------------
    // Classe : Client
    // Responsabilit√© : g√©rer les commandes
    // Collaboration : Commande
    // -----------------------------------------------------

    public class Client {
        private String nom;
        private ArrayList<Commande> commandes = new ArrayList<>();

        /**
         * Ajoute une commande au client.
         * @param commande commande √† ajouter
         */
        public void ajouterCommande(Commande commande) {
            commandes.add(commande);
        }

        /**
         * Affiche toutes les commandes du client.
         */
        public void afficherCommandes() {
            for (Commande c : commandes) {
                System.out.println(c.getResume());
            }
        }
    }

    // -----------------------------------------------------
    // Classe : Commande
    // Responsabilit√© : repr√©senter une commande client
    // Collaboration : Produit
    // -----------------------------------------------------

    public class Commande {
        private int numero;
        private ArrayList<String> produits = new ArrayList<>();

        public Commande(int numero) {
            this.numero = numero;
        }

        public void ajouterProduit(String produit) {
            produits.add(produit);
        }

        public String getResume() {
            return "Commande #" + numero + " ‚Üí " + produits.toString();
        }
    }


// =======================================
// üîç [31] STRUCTURATION D‚ÄôUN PROJET JAVA
// =======================================
// packages, nommage, s√©paration logique

// =======================================
// üîç [32] UTILISATION DES BIBLIOTHEQUES
// =======================================

/**
 * üîπ Java propose des biblioth√®ques (packages) contenant des classes pr√™tes √† l‚Äôemploi.
 * üî∏ Pour les utiliser, on les importe avec `import nom.de.la.classe;`
 */

    // üì¶ java.util : structures de donn√©es, outils g√©n√©raux
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.HashSet;
    import java.util.TreeSet;
    import java.util.Collections;
    import java.util.Random;
    import java.util.Scanner;

    // üì¶ java.io : gestion de fichiers
    import java.io.File;
    import java.io.FileNotFoundException;
    import java.io.PrintWriter;

    // üì¶ java.time : manipulation de dates et heures
    import java.time.LocalDate;
    import java.time.LocalDateTime;

    // üì¶ java.math : calculs math√©matiques avanc√©s
    import java.math.BigDecimal;
    import java.math.RoundingMode;

// ---------------------------------------------------------
// üî∏ Exemple 1 : Scanner pour lire au clavier (java.util)
// ---------------------------------------------------------

    Scanner sc = new Scanner(System.in);
    System.out.print("Entrez votre nom : ");
    String nom = sc.nextLine();

// ---------------------------------------------------------
// üî∏ Exemple 2 : √âcriture dans un fichier (java.io)
// ---------------------------------------------------------

    try {
        PrintWriter writer = new PrintWriter("sortie.txt");
        writer.println("Ceci est un fichier.");
        writer.close();
    } catch (FileNotFoundException e) {
                System.out.println("Erreur d‚Äô√©criture dans le fichier.");
    }


// =======================================
// üîç [33] CLASSES UTILES : STRING, INTEGER, MATH, RANDOM
// =======================================

/**
 * üîπ Ce point regroupe les classes standard les plus utilis√©es en Java.
 * üî∏ Elles contiennent des m√©thodes utilitaires incontournables.
 */

// ----------------------------------------------------
// üî∏ String : manipulation de cha√Ænes de caract√®res
// ----------------------------------------------------

    /**
     * Les cha√Ænes sont immuables.
     * Toutes les m√©thodes renvoient une **nouvelle** cha√Æne.
     */

    String texte = "Bonjour";
    texte.length();               // ‚Üí 7
    texte.charAt(1);              // ‚Üí 'o'
    texte.toUpperCase();          // ‚Üí "BONJOUR"
    texte.substring(1, 4);        // ‚Üí "onj"
    texte.equals("Bonjour");      // comparaison
    texte.contains("jou");        // ‚Üí true
    texte.replace("jour", "soir");// ‚Üí "Bonsoir"

// ----------------------------------------------------
// üî∏ Integer : wrapper pour les entiers
// ----------------------------------------------------

    /**
     * Permet de convertir des cha√Ænes en entiers et vice versa
     */

    int a = Integer.parseInt("123");     // String ‚Üí int
    String s = Integer.toString(456);    // int ‚Üí String
    Integer i = Integer.valueOf(789);    // int ‚Üí Integer objet
    int b = i.intValue();                // Integer ‚Üí int

// ----------------------------------------------------
// üî∏ Math : fonctions math√©matiques
// ----------------------------------------------------

    Math.max(10, 20);             // ‚Üí 20
    Math.min(5, 2);               // ‚Üí 2
    Math.abs(-4);                 // ‚Üí 4
    Math.sqrt(9);                 // ‚Üí 3.0
    Math.pow(2, 3);               // ‚Üí 8.0
    Math.round(3.6);              // ‚Üí 4
    Math.floor(3.9);              // ‚Üí 3.0
    Math.ceil(3.1);               // ‚Üí 4.0
    Math.random();                // ‚Üí double entre 0.0 et 1.0

// ----------------------------------------------------
// üî∏ Random : g√©n√©ration de nombres al√©atoires
// ----------------------------------------------------

    import java.util.Random;

    Random r = new Random();

    int nb = r.nextInt(10);       // ‚Üí entier entre 0 et 9
    boolean tirage = r.nextBoolean(); // ‚Üí true ou false
    double reel = r.nextDouble();     // ‚Üí [0.0, 1.0[


// =======================================
// üîç [34] COLLECTIONS : METHODES UTILES
// =======================================

    import java.util.ArrayList;
    import java.util.Collections;

    /**
     * üîπ La classe `Collections` contient des m√©thodes statiques pour manipuler les collections (List, Set, etc.)
     * üî∏ Tr√®s utilis√©es avec les listes : tri, m√©lange, inversion, recherche, remplacement, etc.
     */

    ArrayList<Integer> liste = new ArrayList<>();
    Collections.addAll(liste, 5, 2, 9, 1, 4);

// ----------------------------------------------------
// üî∏ sort : trie la liste dans l'ordre naturel croissant
// ----------------------------------------------------

    Collections.sort(liste); // [1, 2, 4, 5, 9]

    /**
     * Trie les √©l√©ments d'une liste selon leur ordre naturel
     */

// ----------------------------------------------------
// üî∏ reverse : inverse l‚Äôordre des √©l√©ments
// ----------------------------------------------------

    Collections.reverse(liste); // [9, 5, 4, 2, 1]

    /**
     * Inverse les √©l√©ments de la liste en place
     */

// ----------------------------------------------------
// üî∏ shuffle : m√©lange al√©atoirement les √©l√©ments
// ----------------------------------------------------

    Collections.shuffle(liste);

    /**
     * M√©lange les √©l√©ments de mani√®re al√©atoire
     */

// ----------------------------------------------------
// üî∏ min / max : plus petit et plus grand √©l√©ment
// ----------------------------------------------------

    int minimum = Collections.min(liste);
    int maximum = Collections.max(liste);

    /**
     * Renvoie l‚Äô√©l√©ment minimum/maximum selon l‚Äôordre naturel
     */

// ----------------------------------------------------
// üî∏ binarySearch : recherche binaire (liste tri√©e)
// ----------------------------------------------------

    Collections.sort(liste); // N√©cessaire avant
    int index = Collections.binarySearch(liste, 4);

    /**
     * Recherche d‚Äôun √©l√©ment (renvoie son index ou < 0 si non trouv√©)
     */

// ----------------------------------------------------
// üî∏ Tri d‚Äôobjets avec Comparable
// ----------------------------------------------------

    ArrayList<Personne> personnes = new ArrayList<>();
    personnes.add(new Personne("Alice"));
    personnes.add(new Personne("Zo√©"));
    personnes.add(new Personne("Bob"));

    Collections.sort(personnes); // utilise compareTo ‚Üí tri alphab√©tique

// ----------------------------------------------------
// üî∏ Tri d‚Äôobjets avec Comparator personnalis√©
// ----------------------------------------------------

    Collections.sort(personnes, new ComparateurParLongueur()); // tri par longueur du nom

// ----------------------------------------------------
// üî∏ fill : remplace tous les √©l√©ments d‚Äôune liste
// ----------------------------------------------------

    Collections.fill(liste, 0); // [0, 0, 0, 0, 0]

    /**
     * Remplit toute la liste avec la m√™me valeur
     */

// ----------------------------------------------------
// üî∏ copy : copie le contenu d‚Äôune liste dans une autre
// ----------------------------------------------------

    ArrayList<Integer> dest = new ArrayList<>(Collections.nCopies(liste.size(), 0));
    Collections.copy(dest, liste);

    /**
     * Copie la liste source dans une liste de destination
     * La destination doit avoir la m√™me taille ou plus
     */



// ----------------------------------------------------
// [35] EXCEPTION
// ----------------------------------------------------

// ------------------------------
    // 35.1 Structure try-catch-finally
    // ------------------------------
        System.out.println("== 35.1 try-catch-finally ==");
        try {
    int res = 10 / 0; // Provoque une ArithmeticException (division par z√©ro)
        } catch (ArithmeticException e) {
            System.out.println("Division par z√©ro interdite !");
        } finally {
                // Ce bloc s'ex√©cute toujours, qu'il y ait une exception ou non
                System.out.println("Ce bloc s'ex√©cute toujours !");
        }

                // ------------------------------
                // 35.2 throws et throw
                // ------------------------------
                System.out.println("\n== 35.2 throw et throws ==");
        try {
    testException(); // Cette m√©thode signale qu'elle peut lancer une IOException
        } catch (IOException e) {
            System.out.println("Erreur simul√©e : " + e.getMessage());
            }

            // ------------------------------
            // 35.3 Exception personnalis√©e
            // ------------------------------
            System.out.println("\n== 35.3 Exception personnalis√©e ==");
        try {
    validerNom("Al"); // Nom trop court ‚Üí d√©clenche MauvaisNomException
        } catch (MauvaisNomException e) {
            System.out.println("Erreur sur le nom : " + e.getMessage());
            }

            // ------------------------------
            // 35.4 Exception v√©rifi√©e vs non v√©rifi√©e
            // ------------------------------
            System.out.println("\n== 35.4 Exception v√©rifi√©e vs non v√©rifi√©e ==");

    // Exception v√©rifi√©e (checked) : doit √™tre g√©r√©e par try-catch ou throws
    Exception e1 = new IOException();
        System.out.println("Exception v√©rifi√©e instanci√©e : " + e1);

    // Exception non v√©rifi√©e (unchecked) : pas obligatoire de la g√©rer
    RuntimeException e2 = new NullPointerException();
        System.out.println("Exception non v√©rifi√©e instanci√©e : " + e2);
    }

    // 35.2 : M√©thode qui lance une exception v√©rifi√©e via "throws"
    public static void testException() throws IOException {
        throw new IOException("Fichier introuvable !");
    }

    // 35.3 : M√©thode qui lance une exception personnalis√©e si le nom est trop court
    public static void validerNom(String nom) throws MauvaisNomException {
        if (nom.length() < 3) {
            throw new MauvaisNomException("Nom trop court !");
        } else {
            System.out.println("Nom accept√© : " + nom);
        }
    }
}

    // 35.3 : Classe pour l'exception personnalis√©e
    class MauvaisNomException extends Exception {
        public MauvaisNomException(String message) {
            super(message);
        }
    }


//Test d‚Äôune exception personnalis√©e / ex: probl√®me de saisie
        public class TestProblemeDeSaisieException Exception {
            public static void main(java.lang.String[] args){
                try{
                    operation(args); }
                catch (ProblemeDeSaisieException e) {
                    System.err.println(‚ÄúVeuillez entrer un parameter s‚Äôil vous plait); }

       private void operation(String[] args) throws ProblemeDeSaisieException{
           if (args.length == 0){
               throw new ProblemeDeSaisieException(‚ÄúErreur: pas de param√®tre rentr√©! "); }
           }
       }

import java.util.ArrayList;

                public class Main {
                    public static void main(String[] args) {

                        String[] lignes = {
                                "Chocolat;2.5;30",
                                "Biscuit;abc;20",        // Prix invalide
                                "Pain;1.2;xyz",          // Stock invalide
                                "Fromage;12.0;2000",     // Stock trop grand
                                "Lait;1.5;50",
                                ";;",                    // Mauvais format
                                "Eau;0.9;25"
                        };

                        ArrayList<Produit> produits = parseProduits(lignes);

                        System.out.println("\nProduits valides :");
                        for (Produit p : produits) {
                            System.out.println(p);
                        }
                    }

                    public static ArrayList<Produit> parseProduits(String[] lignes) {
                        ArrayList<Produit> pdc = new ArrayList<>();

                        int compteur = 0;
                        for (String ligne : lignes) {
                            compteur++;
                            if (compteur > 50) break;

                            try {
                                String[] produits = ligne.split(";");
                                if (produits.length != 3) {
                                    throw new Exception("Ligne " + compteur + " ignor√©e : format incorrect");
                                }

                                String nom = produits[0];
                                double prix = Double.parseDouble(produits[1]);
                                int stock = Integer.parseInt(produits[2]);

                                if (prix < 0.5) {
                                    throw new Exception("Ligne " + compteur + " ignor√©e : prix trop bas");
                                }

                                if (stock < 0 || stock > 1000) {
                                    throw new Exception("Ligne " + compteur + " ignor√©e : stock invalide");
                                }

                                pdc.add(new Produit(nom, prix, stock));

                            } catch (NumberFormatException e) {
                                System.out.println("Ligne " + compteur + " ignor√©e : type de valeur incorrect");
                            } catch (Exception e) {
                                System.out.println(e.getMessage());
                            }
                        }

                        return pdc;
                    }
                }


/*
==================
 R√©capitulatif Th√©orique
==================

1. Qu'est-ce qu'une exception ?
Une exception est une erreur qui se produit √† l'ex√©cution du programme. Elle doit √™tre g√©r√©e sinon le programme plante.

2. Trois mani√®res de g√©rer une exception :
- try-catch : g√©rer sur place
- throws : propager vers l'appelant
- throw new : cr√©er et lancer une exception √† la main

3. Exceptions v√©rifi√©es vs non v√©rifi√©es :
- V√©rifi√©e : IOException, SQLException (doivent √™tre g√©r√©es ou remont√©es)
- Non v√©rifi√©e : NullPointerException, ArithmeticException (facultatif)

4. finally :
Bloc ex√©cut√© √† tous les coups, m√™me en cas d'erreur. Utilis√© pour fermer fichiers, nettoyer m√©moire, etc.

5. Mots-cl√©s :
- try : code qui peut planter
- catch : capture une exception
- throw : cr√©er une exception
- throws : annonce que la m√©thode peut lancer une exception
- finally : bloc toujours ex√©cut√©

6. Exemple de classe personnalis√©e : TropPetitException extends Exception

7. A retenir :
- throw new = je cr√©e une exception
- throws = je pr√©viens qu'il y a un risque d'erreur
- try-catch = je r√©agis √† une erreur
- finally = toujours ex√©cut√©
*/



// ==========================================================
// [36] COMPARAISONS EN JAVA
// ==========================================================

    /*----------------------------------------------------------
     * 36.1 == vs .equals()
     *----------------------------------------------------------
     * == compare les r√©f√©rences (adresse en m√©moire)
     * .equals() compare le contenu (si red√©fini dans la classe)
     */

    String a = new String("test");
    String b = new String("test");
System.out.println(a == b);        // false ‚Üí pas m√™me objet
System.out.println(a.equals(b));   // true ‚Üí contenu √©gal

    /*----------------------------------------------------------
     * 36.2 equalsIgnoreCase() pour les cha√Ænes
     *----------------------------------------------------------
     * Compare deux cha√Ænes sans tenir compte des majuscules
     */

    String nom1 = "Alice";
    String nom2 = "alice";
System.out.println(nom1.equalsIgnoreCase(nom2)); // true

    /*----------------------------------------------------------
     * 36.3 Comparaison de nombres
     *----------------------------------------------------------
     */

    int x = 5;
    int y = 10;

System.out.println(x == y);  // false
System.out.println(x < y);   // true
System.out.println(x >= y);  // false

    /*----------------------------------------------------------
     * 36.4 compareTo() sur String (ordre alphab√©tique)
     *----------------------------------------------------------
     * Renvoie :
     *   - n√©gatif si this < autre
     *   - 0 si √©gal
     *   - positif si this > autre
     */

    String s1 = "apple";
    String s2 = "banana";

    int res = s1.compareTo(s2);
System.out.println(res); // < 0 car "apple" vient avant "banana"

    /*----------------------------------------------------------
     * 36.5 compareTo() avec Comparable sur une classe
     *----------------------------------------------------------
     */

    public class Personne implements Comparable<Personne> {
        String nom;

        public int compareTo(Personne autre) {
            return this.nom.compareTo(autre.nom);
        }
    }

    /*----------------------------------------------------------
     * 36.6 Comparator (externe √† la classe)
     *----------------------------------------------------------
     * Utile pour comparer sur un autre crit√®re, par ex. la longueur du nom
     */

    Comparator<Personne> compParLongueur = (p1, p2) -> p1.nom.length() - p2.nom.length();

    /*----------------------------------------------------------
     * 36.7 instanceof (v√©rification de type)
     *----------------------------------------------------------
     */

    Object obj = "Hello";
if (obj instanceof String) {
            System.out.println("C'est une String !");
}

    /*----------------------------------------------------------
     * 36.8 equals() + hashCode() pour objets personnalis√©s
     *----------------------------------------------------------
     */

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Personne other = (Personne) obj;
        return this.nom.equals(other.nom);
    }

    @Override
    public int hashCode() {
        return Objects.hash(nom);
    }


                public class SimpleCompare {

                    // 1) Comparer deux String pour tester une √©galit√© (contenu)
                    public static boolean compareString(String s1, String s2) {
                        // Utilise equals pour comparer le contenu textuel des cha√Ænes
                        return s1.equals(s2);
                    }

                    // 2) Comparer deux int pour tester une √©galit√© (valeur brute)
                    public static boolean compareInt(int i1, int i2) {
                        // Utilise == pour comparer les valeurs num√©riques des primitifs
                        return i1 == i2;
                    }

                    // 3) Comparer deux Integer avec compareTo (valeurs triables)
                    public static void compareIntAlphabetically(Integer i1, Integer i2) {
                        // Utilise compareTo pour trier ou comparer les valeurs
                        int res = i1.compareTo(i2);
                        if (res < 0) {
                            System.out.println(i1 + " est avant " + i2);
                        } else if (res > 0) {
                            System.out.println(i1 + " est apr√®s " + i2);
                        } else {
                            System.out.println(i1 + " est √©gal √† " + i2);
                        }
                    }

                    // 4) Comparer deux String alphab√©tiquement
                    public static void compareStringAlphabetically(String s1, String s2) {
                        // compareTo sur String compare selon l‚Äôordre alphab√©tique
                        int res = s1.compareTo(s2);
                        if (res < 0) {
                            System.out.println(s1 + " est avant " + s2);
                        } else if (res > 0) {
                            System.out.println(s1 + " est apr√®s " + s2);
                        } else {
                            System.out.println(s1 + " est √©gal √† " + s2);
                        }
                    }

                    // 5) Trier une liste de String par ordre alphab√©tique (A ‚Üí Z)
                    public static void sortStringList(List<String> list) {
                        System.out.println("Avant tri : " + list);
                        Collections.sort(list); // sort() trie via compareTo() naturel des String
                        System.out.println("Apr√®s tri : " + list);
                    }

                    // 6) Inverser une liste de String
                    public static void reverseStringList(List<String> list) {
                        System.out.println("Avant inversion : " + list);
                        Collections.reverse(list); // inverse les √©l√©ments (dernier ‚Üí premier)
                        System.out.println("Apr√®s inversion : " + list);
                    }

                    // 7) Comparer deux objets Personne par leur nom (utilise leur getNom)
                    public static void compareAndSortPersonne(Personne a, Personne b) {
                        // compareTo sur les noms des deux objets Personne
                        compareStringAlphabetically(a.getNom(), b.getNom());
                    }

                    // 8) Trier une liste de Personne selon leur nom (via Comparable)
                    public static void sortPersonneList(List<Personne> list) {
                        System.out.println("Avant tri : " + list);
                        // N√©cessite que Personne impl√©mente Comparable<Personne>
                        Collections.sort(list);
                        System.out.println("Apr√®s tri : " + list);
                    }

                    // 9) Trier une liste de Personne selon l‚Äô√¢ge (via Comparator externe)
                    public static void sortPersonneByAge(List<Personne> list) {
                        System.out.println("Avant tri : " + list);
                        // Trie selon l‚Äô√¢ge en utilisant une classe externe PersonneAgeComparator
                        Collections.sort(list, new PersonneAgeComparator());
                        System.out.println("Apr√®s tri : " + list);
                    }

                    // 10) Trier une liste de Personne par nom dans l‚Äôordre d√©croissant (Z ‚Üí A)
                    public static void sortPersonneByNameDesc(List<Personne> list) {
                        System.out.println("Avant tri : " + list);
                        // Utilise un Comparator personnalis√© pour inverser l‚Äôordre alphab√©tique
                        Collections.sort(list, new ComparatorPersonneNomDesc());
                        System.out.println("Apr√®s tri : " + list);
                    }
                }
// ==========================================================
// [37] CAS SP√âCIAUX VUS EN EXAMENS
// ==========================================================

    // 37.1 Examen a blanc 2023
    public class GestionDesExamens {
        // Ces 4 instructions (chargement des donn√©es) seront automatiquement ex√©cut√©es √† chaque test :
        private static ArrayList<Filiere> filieres = chargerFilieres();
        private static ArrayList<Examen> examens = chargerExamens();
        private static ArrayList<Etudiant> etudiants = chargerEtudiants();

        static {
            chargerInscriptions();
        }

        /**
         * Charge le fichier "LstFilieres.csv" dans l'ArrayList filieres.
         */
        private static ArrayList<Filiere> chargerFilieres() {
            filieres = new ArrayList<>();
            for (String[] ligne : FileToStr.lireCsv("src/TP11_Correction_Exa_2020/ExaQ1_GestionExamens/LstFilieres.csv")) {
                filieres.add(new Filiere(ligne[0], ligne[1], ligne[2]));
            }
            return filieres;
        }

        /**
         * Charge le fichier "LstExamens.csv" dans l'ArrayList examens.
         * La m√©thode FileToStr.lireCsv() retourne un tableau √† 2 dimensions : lignes & colonnes.
         */
        private static ArrayList<Examen> chargerExamens() {
            examens = new ArrayList<>();
            for (String[] ligne : FileToStr.lireCsv("src/TP11_Correction_Exa_2020/ExaQ1_GestionExamens/LstExamens.csv")) {
                // ===== √Ä COMPL√âTER =====
                //creer les bons attributs, creer l'objet examen, ajouter dans la liste
                //41;IG;632-2 R√©seau;8;8;FR13
                int no = Integer.parseInt(ligne[0]);
                String codeFiliere = ligne[1];
                String module = ligne[2];
                int jour = Integer.parseInt(ligne[3]);
                int heure = Integer.parseInt(ligne[4]);
                String lieu = ligne[5];
                Filiere filiere = trouverFiliere(codeFiliere);
                Examen exa = new Examen(no, module, jour, heure, lieu, filiere);
                examens.add(exa);

            }
            return examens;
        }

        private static Filiere trouverFiliere(String codeFiliere) {
            for (Filiere filiere : filieres) {
                if(codeFiliere.equals(filiere.getCode())){
                    return filiere;
                }
            }
            return null;
        }

        /**
         * Charge le fichier "LstEtudiants.csv" dans l'ArrayList etudiants.
         * La m√©thode FileToStr.lireCsv() retourne un tableau √† 2 dimensions : lignes & colonnes.
         */
        private static ArrayList<Etudiant> chargerEtudiants() {
            etudiants = new ArrayList<>();
            for (String[] ligne : FileToStr.lireCsv("src/TP11_Correction_Exa_2020/ExaQ1_GestionExamens/LstEtudiants.csv")) {
                // ===== √Ä COMPL√âTER =====
                //401;Gaston;Lagaffe;IG
                int no = Integer.parseInt(ligne[0]);
                String nom = ligne[2];
                String prenom = ligne[1];
                String codeFiliere = ligne[3];
                Filiere filiere = trouverFiliere(codeFiliere);
                Etudiant etu = new Etudiant(no, nom, prenom, filiere);
                etudiants.add(etu);
            }
            return etudiants;
        }

        /**
         * Enregistre quel √©tudiant est inscrit √† quel examen.
         * C'est √† vous de choisir o√π et comment conserver ces informations.
         * Le fichier "LstInscriptions.csv" contient la liste des √©tudiants, avec la liste des examens auquels ils sont inscrits.
         * La m√©thode FileToStr.lireCsv() retourne un tableau √† 2 dimensions : lignes & colonnes.
         */
        private static void chargerInscriptions() {
            for (String[] ligne : FileToStr.lireCsv("src/TP11_Correction_Exa_2020/ExaQ1_GestionExamens/LstInscriptions.csv")) {
                // ===== √Ä COMPL√âTER =====
                //101;11;12;13;16
                int noEtu = Integer.parseInt(ligne[0]);
                Etudiant etu = trouverEtudiant(noEtu);
                for(int i = 1; i < ligne.length; i++){
                    int noExa = Integer.parseInt(ligne[i]);
                    Examen exa = trouverExamen(noExa);
                    if(exa != null && etu != null){
                        exa.addEtudiant(etu);
                        etu.addExamen(exa);
                    }
                }
            }
        }

        private static Examen trouverExamen(int noExa) {
            for(Examen exa : examens){
                if(exa.getNo() == noExa){
                    return exa;
                }
            }
            return null;
        }

        private static Etudiant trouverEtudiant(int noEtu) {
            for (Etudiant etu : etudiants) {
                if(noEtu == etu.getNo()){
                    return etu;
                }
            }
            return null;
        }

        /**
         * Affiche le contenu des 3 ArrayList globales : filieres, examens et etudiants.
         */
        public static void afficherTout() {
            System.out.println("\nFilieres :  ");
            for (Filiere fil : filieres) {
                System.out.println(fil);
            }
            System.out.println("\nExamens :   ");
            for (Examen exa : examens) {
                System.out.println(exa);
            }
            System.out.println("\nEtudiants : ");
            for (Etudiant etu : etudiants) {
                System.out.println(etu);
            }
        }

        /**
         * Affiche l'examen qui a eu lieu tel jour, telle heure dans ce lieu, ainsi que la liste des √©tudiants inscrits.
         */
        public static void afficherQuiEtaitLa(int jour, int heure, String lieu) {
            // ===== √Ä COMPL√âTER =====
            boolean trouveExam = false;
            for(Examen exa : examens){
                if(exa.presenceExamen(jour, heure, lieu)){
                    trouveExam = true;
                    exa.afficherEtudiantsInscrits();
                }
            }
            if(!trouveExam){
                //Aucun examen le 10 √† 9h, lieu: B4.11
                System.out.println("\nAucun examen le " + jour + " √† " + heure + "h, lieu: " + lieu);
            }
        }

        /**
         * Affiche la liste des examens auxquels est inscrit nom-prenom.
         */
        public static void afficherMesExamens(String nom, String prenom) {
            // ===== √Ä COMPL√âTER =====
            boolean trouveEtudiant = false;
            for(Etudiant etu : etudiants){
                if(etu.getPrenom().equals(prenom) && etu.getNom().equals(nom)){
                    trouveEtudiant = true;
                    etu.afficherExamens();
                }
            }
            if(!trouveEtudiant){
                //Aucun √©tudiant trouv√© avec le nom et pr√©nom donn√©s
                System.out.println("\nEtudiant " + nom + " " + prenom + " inconnu !");
            }
        }
    }
// 37.2 Examen Cinema
public class Cinema {
    private static ArrayList<Film> catalogueFilms = new ArrayList<>();
    private static HashSet<Seance> seances = new HashSet<>();
    private static HashMap<Seance, ArrayList<Integer>> reservations = new HashMap<>();

    //Donn√©
    public static void chargerDonneesFilms(String[] donnees){
        for (String ligne : donnees){
            String[] element = ligne.split(";");
            catalogueFilms.add(new Film(element[0], Integer.parseInt(element[1]), element[2]));
        }
    }

    public static void chargerDonneesSeances(String[] donnees){
        int cptLigne = 1;
        for (String ligne : donnees){

            String[] element = ligne.split(";");
            Film f = new Film(element[1]);
            f = rechercheFilm(f);
            try{
                Seance s = new Seance(Integer.parseInt(element[0]), f, element[2], element[3]);
                seances.add(s);
            }catch (FilmIntrouvableException e) {
                System.out.println("Ligne " + cptLigne + " ("+ element[1] +") - " + e.getMessage());
            }
            cptLigne++;
        }
    }


    public static Film rechercheFilm(Film f){
        for(Film fi : catalogueFilms) {
            if (fi.equals(f)) {
                return fi;
            }
        }
        return null;
    }

    public static Seance rechercheSeance(Seance s){
        for(Seance se : seances) {
            if (se.equals(s)) {
                return se;
            }
        }
        return null;
    }

    public static void chargerDonneesReservations(String[] donnees){
        int cptLigne = 1;
        for (String ligne : donnees){

            String[] element = ligne.split(";");
            Seance s = new Seance(Integer.parseInt(element[0]));
            int[] sieges = new int[element.length-1];
            for (int i = 0; i < element.length -1; i ++){
                sieges[i] = Integer.parseInt(element[i+1]);
            }
            s = rechercheSeance(s);
            try{
                insertionHashMap(s,sieges);
            }catch (SiegeOccupeException e) {
                System.out.println("Ligne " + cptLigne + " - " + e.getMessage());
            }
            cptLigne++;
        }
    }

    public static void insertionHashMap(Seance s, int[] sieges) throws SiegeOccupeException{
        if(reservations.containsKey(s)){
            for (int si : sieges) {
                if (reservations.get(s).contains(si)) {
                    throw new SiegeOccupeException("Le siege " + si + " de la seance " + s +" est deja reserve ! La reservation n'est donc pas prise en compte.");
                }
            }
        }
        else{
            reservations.put(s,new ArrayList<>());
        }
        for(int si : sieges){
            reservations.get(s).add(si);
        }
    }

    public static void afficherCatalogue(String tri){
        if(tri.equals("naturel")){
            catalogueFilms.sort(null);
        }else if(tri.equals("titre")){
            catalogueFilms.sort(new CompareParTitre());
        }else if(tri.equals("duree")){
            catalogueFilms.sort(new CompareParDuree());
        }
        for(Film f : catalogueFilms){
            System.out.println(f);
        }
    }

//37.3 Examen 2024 votation

    public class StatVotations {
        private static final String FILENAME_DATA = "results.csv";
        private static final String FILENAME_STAT = "stats.txt";
        private static final String FILENAME_ERROR = "errors.log";
        private static final int NB_CHAMPS = 5;
        private static final int MAX_LENGTH = 50;
        private static String erreurs ="";

        private static HashSet<Result> results = new HashSet<>();

        public static void main(String[] args) {
            chargerResultats();
            calculerStat();
        }

        /**
         * TODO: Cr√©er un r√©sultat
         * col 0 = nom Commune - String
         * col 1 = nbElecteurs - int
         * col 2 = nbOui - int
         * col 3 = nbNon - int
         * col 4 = nbBlanc - int
         * length!=5 = ERREUR A propager et traiter!
         * TODO: l'ajouter dans l'ensemble des r√©sultats
         * TODO: Faire attention √†:
         * TODO: v√©rifier qu le nb d'√©l√©ments <=5
         * ....
         * TODO: signaler erreur xy
         * TODO: sauver erreur dans error.logs
         * etc.....
         */
        private static void chargerResultats() {
            // TODO: lire le fichier FILENAME_DATA
            // TODO: stocker les r√©sultats corrects dans le HashSet results
            // TODO: appeler erreur() pour enregistrer les erreurs dans FILENAME_ERROR
            try {
                ArrayList<String[]> fichierResultats = FileToStr.lireFichier(FILENAME_DATA);
                for (int i = 1; i < fichierResultats.size() ; i++) {
                    if(i>MAX_LENGTH-1)return;
                    String[] ligne = fichierResultats.get(i);
                    try {
                        if(ligne.length!=NB_CHAMPS){
                            throw new ColumnLengthException("Erreur ligne "+(i+1)+" "+ Arrays.toString(ligne)+": IL y a "+ligne.length+" valeurs au lieu de "+NB_CHAMPS);
                        }
                        String nomCommune = ligne[0].trim();
                        String nbElecteurs = ligne[1].trim();
                        String nbOui = ligne[2].trim();
                        String nbNon = ligne[3].trim();
                        String nbBlanc = ligne[4].trim();
                        Result resultat = new Result(nomCommune,nbElecteurs,nbOui,nbNon,nbBlanc);
                        if(results.contains(resultat)){
                            throw new ExistingCommuneException("La commune "+resultat.getCommune()+" a d√©j√† √©t√© enregistr√©e");
                        }
                        results.add(resultat);
                    }
                    catch (BadCommuneNameExceptions badCommuneNameExceptions) {
                        System.err.println(erreur("Erreur ligne "+(i+1)+" "+ formattedLigne(ligne)+": "+badCommuneNameExceptions.getMessage()+" !")); }
                    catch (NotNumericNumberException numberFormatException){
                        System.err.println(erreur("Erreur ligne "+(i+1)+" "+ formattedLigne(ligne)+": "+numberFormatException.getMessage()+" !"));
                    } catch (ColumnLengthException columnLengthException) {
                        System.err.println(erreur("Erreur ligne "+(i+1)+" "+ formattedLigne(ligne)+": "+columnLengthException.getMessage()+" !"));
                    } catch (InvalidNumberExceptions invalidNumberExceptions) {
                        System.err.println(erreur("Erreur ligne "+(i+1)+" "+ formattedLigne(ligne)+": "+invalidNumberExceptions.getMessage()+" !"));
                    } catch (ExistingCommuneException existingCommuneException) {
                        System.err.println(erreur("Erreur ligne "+(i+1)+" "+ formattedLigne(ligne)+": "+existingCommuneException.getMessage()+" !"));
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        private static String formattedLigne(String[] ligne) {
            return Arrays.toString(ligne).replace('[','(').replace(']',')');
        }

        //37.4 Examen gestion des alarmes (out of bounds)

        public class GestionAlarme {

            private static ArrayList<Personne> personnes = new ArrayList<>();
            private static ArrayList<Alarmable> entite = new ArrayList<>();

            public static ArrayList<Personne> chargerPersonnes(String fichier) {
                String[] lignes = FileToStr.lireCsv(fichier);

                for (int i = 0; i < lignes.length; i++) {
                    String[] data = lignes[i].split(";");

                    // On cr√©e les variables une par une
                    int id = Integer.parseInt(data[0]);
                    String nom = data[1];

                    String telPrive = "";
                    if (data.length > 2 && !data[2].equals("")) {
                        telPrive = data[2];
                    } else {
                        telPrive = null;
                    }

                    String telPro = "";
                    if (data.length > 3 && !data[3].equals("")) {
                        telPro = data[3];
                    } else {
                        telPro = null;
                    }

                    String email = "";
                    if (data.length > 4 && !data[4].equals("")) {
                        email = data[4];
                    } else {
                        email = null;
                    }

                    // Cr√©ation de l'objet
                    Personne p = new Personne(id, nom, telPrive, telPro, email);
                    personnes.add(p);
                }

                return personnes;
            }

            public static ArrayList<Alarmable> chargerAlarmables(String fichier) {
                String[] lignes = FileToStr.lireCsv(fichier);
                for (int i = 0; i < lignes.length; i++) {
                    String[] data = lignes[i].split(";");
                    String type = data[0];
                    Alarmable alarme = null;
                    int id = Integer.parseInt(data[1]);
                    Personne p = getPersonne(id);
                    if (type.equals("D")) {
                        String address = data[2];
                        alarme = new DomicilePrive(address, p);
                    } else if (type.equals("E")) {
                        String nomEntreprise = data[2];
                        String address = data[3];
                        int nbEmploye = Integer.parseInt(data[4]);
                        alarme = new Entreprise(nomEntreprise, address, nbEmploye, p);
                    } else {
                        String nomEntreprise = data[2];
                        String address = data[3];
                        alarme = new InstitutionPublique(nomEntreprise, address, p);

                    }
                    entite.add(alarme);
                }
                return entite;
            }

            public static Personne getPersonne(int id) {
                Personne recherche = new Personne(id);

                for (Personne p : personnes) {
                    if (p.equals(recherche)) {
                        return p;
                    }
                }
                return null;
            }





// ==========================================================
// [38] Chargement de donn√©es, charge data et FileReader et Writer
// =========================================================

   // Avec SPLIT

   public void loadData(){
       String[] dataFile = FileToStr.lireCsv("file.csv");
       for(String line : dataFile){
           String[] columns = line.split(";");
           String column0 = column[0];
           int column1 =Integer.parseInt(column[1]);
       }
   }

   // Sans SPLIT

    public void loadData(){
        ArrayList<String[]> dataFile = FileToStr.lireCsv("file.csv");
        for(String[] line : dataFile){
        String column0 = line[0];
        int column1 =Integer.parseInt(line[1]);
        }
    }

        /*----------------------------------------------------------
         * 38.1 Lecture ligne par ligne depuis un fichier texte
         *----------------------------------------------------------
         */

        public static void lireFichierLignes(String chemin) {
            try (BufferedReader br = new BufferedReader(new FileReader(chemin))) {
                String ligne;
                while ((ligne = br.readLine()) != null) {
                    System.out.println(ligne);
                }
            } catch (IOException e) {
                System.out.println("Erreur de lecture : " + e.getMessage());
            }
        }

        /*----------------------------------------------------------
         * 38.2 Chargement d‚Äôun CSV dans un tableau simple
         *----------------------------------------------------------
         * Exemple de fichier : donn√©es.csv
         * Contenu :
         * 10
         * 20
         * 30
         */

        public static int[] chargerCSVdansTableau(String chemin) throws IOException {
            ArrayList<Integer> liste = new ArrayList<>();
            try (BufferedReader br = new BufferedReader(new FileReader(chemin))) {
                String ligne;
                while ((ligne = br.readLine()) != null) {
                    liste.add(Integer.parseInt(ligne.trim()));
                }
            }
            // Conversion ArrayList ‚Üí tableau
            int[] resultat = new int[liste.size()];
            for (int i = 0; i < liste.size(); i++) {
                resultat[i] = liste.get(i);
            }
            return resultat;
        }

            public class Bdd {
                public static List<Table> getListeTables() {
                    List<Table> data = new ArrayList<>();
                    try {
                        BufferedReader reader = new BufferedReader(new FileReader("src/TP10_Correction/Ex2/LstTables.csv"));
                        String ligne;
                        while ((ligne = reader.readLine()) != null) {
                            String[] champs = ligne.split(";");
                            if (champs[0].startsWith("R")) {
                                data.add(new TableRect(champs[0], Integer.parseInt(champs[1]), Matiere.valueOf(champs[2]), Integer.parseInt(champs[3]), Integer.parseInt(champs[4])));
                            } else {
                                data.add(new TableRonde(champs[0], Integer.parseInt(champs[1]), Matiere.valueOf(champs[2]), Integer.parseInt(champs[3])));
                            }
                        }
                        reader.close();
                    } catch (IOException e) {
                        System.out.println("Erreur lors de la lecture du fichier : " + e.getMessage());
                    }
                    return data;
                }
            }

        /*----------------------------------------------------------
         * 38.3 Chargement d‚Äôun CSV dans un tableau 2D (matrice)
         *----------------------------------------------------------
         * Exemple de fichier : matrice.csv
         * Contenu :
         * 1;2;3
         * 4;5;6
         */

        public static int[][] chargerMatriceDepuisCSV(String chemin) throws IOException {
            ArrayList<int[]> lignes = new ArrayList<>();
            try (BufferedReader br = new BufferedReader(new FileReader(chemin))) {
                String ligne;
                while ((ligne = br.readLine()) != null) {
                    String[] valeurs = ligne.split(";");
                    int[] ligneInt = new int[valeurs.length];
                    for (int i = 0; i < valeurs.length; i++) {
                        ligneInt[i] = Integer.parseInt(valeurs[i].trim());
                    }
                    lignes.add(ligneInt);
                }
            }
            // Conversion en tableau 2D
            int[][] matrice = new int[lignes.size()][];
            for (int i = 0; i < lignes.size(); i++) {
                matrice[i] = lignes.get(i);
            }
            return matrice;
        }

        /*----------------------------------------------------------
         * 38.4 Chargement d‚Äôun CSV dans une ArrayList<String[]>
         *----------------------------------------------------------
         * Exemple de fichier : personnes.csv
         * Contenu :
         * Alice;25
         * Bob;30
         */

        public static ArrayList<String[]> chargerLignesCSV(String chemin) {
            ArrayList<String[]> donnees = new ArrayList<>();
            try (BufferedReader br = new BufferedReader(new FileReader(chemin))) {
                String ligne;
                while ((ligne = br.readLine()) != null) {
                    String[] champs = ligne.split(";");
                    donnees.add(champs);
                }
            } catch (IOException e) {
                System.out.println("Erreur de lecture : " + e.getMessage());
            }
            return donnees;
        }

// ==========================================================
// [38.5] CHARGEMENT D‚ÄôUN CSV DANS UN TABLEAU DE String[][]
// ==========================================================

            /*
             * Exemple de fichier CSV (fichier : "eleves.csv")
             * Alice;18;Math
             * Bob;20;Info
             * Clara;17;Histoire
             */

            public static String[][] chargerCSVString2D(String chemin) {
                ArrayList<String[]> lignes = new ArrayList<>();

                try (BufferedReader br = new BufferedReader(new FileReader(chemin))) {
                    String ligne;
                    while ((ligne = br.readLine()) != null) {
                        // D√©coupe chaque ligne sur le point-virgule
                        String[] champs = ligne.split(";");
                        lignes.add(champs); // Ajoute le tableau de champs √† la liste
                    }
                } catch (IOException e) {
                    System.out.println("Erreur lors de la lecture du fichier : " + e.getMessage());
                }

                // Conversion ArrayList ‚Üí tableau 2D
                String[][] resultat = new String[lignes.size()][];
                for (int i = 0; i < lignes.size(); i++) {
                    resultat[i] = lignes.get(i);
                }

                return resultat;
            }

// ==========================================================
// [38.7] Charger data double tableau
// ==========================================================

            public static void chargerLivres(String[][] fichier) {
                for (int i = 0; i < fichier.length; i++) {
                    int id = Integer.parseInt(fichier[i][0]);
                    String titre = fichier[i][1];
                    String auteur = fichier[i][2];
                    int annee = Integer.parseInt(fichier[i][3]);

                    Livre livre = new Livre(id, titre, auteur, annee);

                    livres.add(livre);
                    livresMap.put(id, livre);
                }
            }

            public static void afficherTousLesLivres() {
                for (Livre livre : livres) {
                    System.out.println(livre);
                }
            }

            public static void afficherLivreParId(int idRecherche) {
                Livre livre = livresMap.get(idRecherche);
                if (livre != null) {
                    System.out.println("Le livre est : " + livre);
                } else {
                    System.out.println("Aucun livre trouv√© avec cet ID.");
                }
            }

// ==========================================================
// [38.8] Exercice Forum Admin, modo
// ==========================================================

       public class Forum
       {
           private static ArrayList<ExaQ2_ForumEnLigne.Utilisateur> utilisateurs = new ArrayList<>();
           private static HashMap<String, ArrayList<Message>> sujets = new HashMap<>();
           private static HashSet<String> utilisateursConnectes = new HashSet<>();

           /**
            * Constructeur d'objets de classe Forum
            */
           public Forum(){}

           public void chargerUsers(String path){
               String [] ligne = FileToStr.lireCsv(path);
               for(String str : ligne){
                   String[] element = str.split(";");
                   String typeUser = element[0];
                   String pseudo = element[1];
                   String nom = element[2];
                   String prenom = element[3];
                   if(typeUser.equals("Administrateur")){
                       String typeAccess = element[4];
                       int nbBugs = Integer.parseInt(element[5]);
                       Administrateur a = new Administrateur(pseudo, nom, prenom, typeAccess, nbBugs);
                       utilisateurs.add(a);
                   } else if(typeUser.equals("Moderateur")){
                       int tel = Integer.parseInt(element[4]);
                       int nbBanni = Integer.parseInt(element[5]);
                       Moderateur m = new Moderateur(pseudo, nom, prenom, tel, nbBanni);
                       utilisateurs.add(m);
                   } else {
                       int tel = Integer.parseInt(element[4]);
                       Membre membre = new Membre(pseudo, nom, prenom, tel);
                       utilisateurs.add(membre);
                   }

               }
           }

           public void chargerSujets(String path){
               String [] ligne = FileToStr.lireCsv(path);
               for(String str : ligne){
                   ArrayList<Message> messages = new ArrayList<>();
                   String[] element = str.split(";");
                   String sujet = element[0];
                   String pseudo = element[1];
                   ExaQ2_ForumEnLigne.Utilisateur auteur = chercherUser(pseudo);
                   String contenu = element[2];
                   Message mess = new Message(auteur, contenu);
                   messages.add(mess);
                   sujets.putIfAbsent(sujet, new ArrayList<>());
                   sujets.get(sujet).add(mess);
               }

           }

           public ExaQ2_ForumEnLigne.Utilisateur chercherUser(String pseudo) {
               for (ExaQ2_ForumEnLigne.Utilisateur u : utilisateurs) {
                   if (u.getPseudo().equals(pseudo)) {
                       return u;
                   }
               }
               return null;
           }

           public void connexion(ExaQ2_ForumEnLigne.Utilisateur user){
               // Ne pas modifier
               utilisateursConnectes.add(user.getPseudo());
               user.messageConnexion();
           }

           public void deconnexion(ExaQ2_ForumEnLigne.Utilisateur user){
               utilisateursConnectes.remove(user.getPseudo());
               user.messageDeconnexion();
           }

           public void afficherUtilisateurs(){
               for (ExaQ2_ForumEnLigne.Utilisateur u : utilisateurs){
                   System.out.println(u.getPseudo() + " (" + u.getPrenom() + " " + u.getNom() + ")");
               }
           }


           public void afficherUtilisateursEnLigne(){
               for (String s : utilisateursConnectes) {
                   System.out.println(s);
               }
           }

           public static void afficherSujets(){
               for (String sujet : sujets.keySet()) {
                   System.out.println("[" + sujet + "] ");
                   ArrayList<Message> listeMessages = sujets.get(sujet);
                   for (Message msg : listeMessages) {
                       System.out.println("\t" + msg);
                   }
               }
           }


           public static void main(String[] args){
               ExaQ2_ForumEnLigne.Forum f = new ExaQ2_ForumEnLigne.Forum();
               f.chargerUsers("utilisateurs.csv");
               f.chargerSujets("messages.csv");
               f.afficherUtilisateurs();

               System.out.println("Connexions :\n ----------------");
               f.connexion(utilisateurs.get(0));
               f.connexion(utilisateurs.get(4));
               f.connexion(utilisateurs.get(7));
               f.connexion(utilisateurs.get(10));
               System.out.println();
               System.out.println("Utilsateur connect√© :\n ----------------");
               f.afficherUtilisateursEnLigne();
               System.out.println();
               System.out.println("D√©connexions :\n ----------------");
               f.deconnexion(utilisateurs.get(0));
               f.deconnexion(utilisateurs.get(4));
               f.deconnexion(utilisateurs.get(10));
               System.out.println();
               f.afficherSujets();
           }
       }

// ==========================================================
// [38.9] Exercice DRUG
// ==========================================================

package ExaQ3_DrugManagement;

import java.util.ArrayList;
import java.util.Collections;

            /**
             * D√©crivez votre classe DrugEvaluator ici.
             *
             * @author (votre nom)
             */
            public class DrugEvaluator {

                private static ArrayList<Substance> drugs = new ArrayList<>();

                private static void loadSubstances() {
                    boolean isFirstRow = true;
                    String[] csv = FileToStr.lireCsv("substances.csv");
                    for (String row : csv) {
                        if (isFirstRow){
                            isFirstRow = false;
                        }else {
                            String[] columns = row.split(";");
                            //name;socialHarm;isLegal;physicalHarm;strength;type
                            String name = columns[0];
                            int socialHarm = Integer.parseInt(columns[1]);
                            boolean isLegal = Boolean.parseBoolean(columns[2]);
                            int physicalHarm = Integer.parseInt(columns[3]);
                            int strength = Integer.parseInt(columns[4]);
                            String type = columns[5];

                            if (type.equals("depressant")) {
                                Depressant dep = new Depressant(name, socialHarm, isLegal, physicalHarm, strength);
                                drugs.add(dep);
                            }
                            else if (type.equals("dissociative")) {
                                Dissociative diss = new Dissociative(name, socialHarm, isLegal, physicalHarm, strength);
                                drugs.add(diss);
                            } else if (type.equals("enctatogen")) {
                                Enctatogen enc = new Enctatogen(name, socialHarm, isLegal, physicalHarm, strength);
                                drugs.add(enc);
                            } else if (type.equals("psychedelic")) {
                                Psychedelic psy = new Psychedelic(name, socialHarm, isLegal, physicalHarm, strength);
                                drugs.add(psy);
                            } else {
                                Stimulant sti = new Stimulant(name, socialHarm, isLegal, physicalHarm, strength);
                                drugs.add(sti);
                            }
                        }
                    }
                }

                /**
                 * remplacez ce commentaire par le v√¥tre
                 *
                 * @param  args   le param√®tre de la m√©thode
                 */
                public static void main (String[]args){
                    loadSubstances();
                    displaySubstances();
                    System.out.println("----------Tri par d√©faut----------");
                    sortBy("d");
                    displaySubstances();
                    System.out.println("----------Tri par danger----------");
                    sortBy("danger");
                    displaySubstances();
                }

                /**
                 * remplacez ce commentaire par le v√¥tre
                 *
                 * @param  criteria   le param√®tre de la m√©thode
                 */
                private static void sortBy(String criteria) {
                    switch (criteria) {
                        case "d":
                            Collections.sort(drugs);
                            break;
                        case "danger":
                            Collections.sort(drugs, new CompareByDanger());
                            break;
                        case "name":
                            Collections.sort(drugs, new CompareByName());
                            break;
                        default:
                            System.out.println("Crit√®re inconnu. Tri par nom par d√©faut.");
                            Collections.sort(drugs, new CompareByName());
                    }
                }


                /**
                 * remplacez ce commentaire par le v√¥tre
                 *
                 */
                private static void displaySubstances() {
                    for (Substance substance : drugs) {
                        System.out.println(substance);
                    }
                }

            }


            package ExaQ3_DrugManagement;

            /**
             * D√©crivez votre classe Substance ici.
             *
             * @author (votre nom)
             */
// A compl√©ter
            public abstract class Substance implements IScorable, Comparable<ExaQ3_DrugManagement.Substance>
            {

                private String name;
                private int socialHarm;
                private boolean isLegal;
                private int physicalHarm;
                private int strength;

                /**
                 * Constructeur d'objets de classe Substance
                 */
                protected Substance(String name, int socialHarm, boolean isLegal, int physicalHarm, int strength)
                {
                    // initialisation des variables d'instance
                    this.name = name;
                    this.socialHarm = socialHarm;
                    this.isLegal = isLegal;
                    this.physicalHarm = physicalHarm;
                    this.strength = strength;
                }

                protected int getStrength() {
                    return strength;
                }

                protected String getName() {
                    return name;
                }

                protected void setName(String name) {
                    this.name = name;
                }

                protected int getSocialHarm() {
                    return socialHarm;
                }

                protected void setSocialHarm(int socialHarm) {
                    this.socialHarm = socialHarm;
                }

                protected Boolean isLegal() {
                    return isLegal;
                }

                protected void setLegal(boolean legal) {
                    isLegal = legal;
                }

                protected int getPhysicalHarm() {
                    return physicalHarm;
                }

                protected void setPhysicalHarm(int physicalHarm) {
                    this.physicalHarm = physicalHarm;
                }

                protected abstract String harms();

                protected abstract String heals();

                @Override
                public int getDangerScore() {
                    return strength * (socialHarm + physicalHarm);
                }

                @Override
                public int compareTo(ExaQ3_DrugManagement.Substance sub) {
                    int compareType = this.getClass().getSimpleName().compareTo(sub.getClass().getSimpleName());
                    if (compareType != 0) {
                        return compareType;
                    }

                    int compareName = this.name.compareTo(sub.name);
                    if (compareName != 0) {
                        return compareName;
                    }

                    return Integer.compare(this.strength, sub.strength);
                }



                public interface ILethal {
                    String DISCLAIMER = "est potentiellement dangereux";

                    String disclaimer();
                }

                public class CompareByDanger implements Comparator<ExaQ3_DrugManagement.Substance> {

                    @Override
                    public int compare(ExaQ3_DrugManagement.Substance o1, ExaQ3_DrugManagement.Substance o2) {
                        return o1.getDangerScore() - o2.getDangerScore();
                    }
                }


                @Override
                public String toString() {
                    // A compl√©ter
                    return name  + " ("+ (isLegal() ? "l√©gal" : "ill√©gal") +")"+
                            " -  Cat√©gorie "+'"' + this.getClass().getSimpleName()+ '"'+
                            "\n ¬¶ m√©faits: "+ harms() +
                            "\n ¬¶ bienfaits: "+ heals() +
                            "\n ¬¶ nuisance sociale: " + getSocialHarm() + "/50" +
                            "\n ¬¶ nuisance physique: " + getPhysicalHarm() + "/50" +
                            "\n ¬¶ force: " + getStrength()+"/10"+
                            "\n ¬¶ dangerosit√© de " + getDangerScore() + "/1000" +
                            "\n ¬¶ ATTENTION ";
                }

            }

            public class Depressant
                    extends ExaQ3_DrugManagement.Substance implements ILethal {


                /**
                 * Constructeur d'objets de classe Substance
                 *
                 * @param name
                 * @param socialHarm
                 * @param isLegal
                 * @param physicalHarm
                 * @param strength
                 */

                public Depressant(String name, int socialHarm, boolean isLegal, int physicalHarm, int strength) {
                    super(name, socialHarm, isLegal, physicalHarm, strength);
                }

                protected String harms() {
                    return "ralentit l'activit√© du syst√®me nerveux central et s√©date";
                }

                protected String heals() {

                    return "procure une senstation de bien √™tre";
                }


                public String disclaimer() {
                    // A compl√©ter
                    return DISCLAIMER   ;
                }

                @Override
                public String toString() {
                    return super.toString() + disclaimer();
                }
            }

// ==========================================================
// [38.10] Exo Votations
// ==========================================================

import java.io.*;
import java.util.*;

            public class StatVotations {
                private static final String FILENAME = "results.csv";
                private static final String ERROR_FILE = "errors.log";
                private static final String STAT_FILE = "stats.txt";
                private static Set<Result> results = new HashSet<>();
                private static Set<String> communesVues = new HashSet<>();
                private static boolean erreurGrave = false;

                public static void main(String[] args) {
                    try {
                        chargerResultats();
                        if (!erreurGrave) calculerStat();
                        for (Result r : results) {
                            System.out.println(r.toStringLong());
                        }
                    } catch (Exception e) {
                        System.out.println("Erreur grave lors de la lecture: " + e.getMessage());
                        erreurGrave = true;
                    }
                }

                private static void chargerResultats() {
                    try (BufferedReader br = new BufferedReader(new FileReader(FILENAME));
                         BufferedWriter log = new BufferedWriter(new FileWriter(ERROR_FILE))) {

                        String ligne;
                        int nbLigne = 0;

                        // Ignore l'en-t√™te
                        br.readLine();

                        while ((ligne = br.readLine()) != null && nbLigne < 50) {
                            nbLigne++;
                            String[] parts = ligne.split(";");

                            if (parts.length != 5) {
                                erreur(log, nbLigne + 1, ligne, "il y a " + parts.length + " valeurs au lieu de 5 !");
                                continue;
                            }

                            String nomCommune = parts[0].trim();

                            try {
                                int electeurs = Integer.parseInt(parts[1]);
                                int oui = Integer.parseInt(parts[2]);
                                int non = Integer.parseInt(parts[3]);
                                int blanc = Integer.parseInt(parts[4]);

                                if (electeurs < 0 || oui < 0 || non < 0 || blanc < 0) {
                                    erreur(log, nbLigne + 1, ligne, "nombre erron√© !");
                                    continue;
                                }
                                if (oui + non + blanc > electeurs) {
                                    erreur(log, nbLigne + 1, ligne, "trop de votes par rapport aux √©lecteurs !");
                                    continue;
                                }
                                if (nomCommune.length() < 2) {
                                    erreur(log, nbLigne + 1, ligne, "nom de commune '" + nomCommune + "' erron√© !");
                                    continue;
                                }
                                if (communesVues.contains(nomCommune)) {
                                    erreur(log, nbLigne + 1, ligne, "la commune " + nomCommune + " a d√©j√† √©t√© enregistr√©e !");
                                    continue;
                                }

                                Result r = new Result(nomCommune, electeurs, oui, non, blanc);
                                results.add(r);
                                communesVues.add(nomCommune);

                            } catch (NumberFormatException e) {
                                erreur(log, nbLigne + 1, ligne, "nombre non num√©rique !");
                            }
                        }
                    } catch (IOException e) {
                        System.out.println("Erreur de lecture: " + e.getMessage());
                        erreurGrave = true;
                    }
                }

                private static void erreur(BufferedWriter log, int ligne, String contenu, String message) throws IOException {
                    String msg = "Erreur ligne " + ligne + " (" + contenu + ") : " + message;
                    log.write(msg);
                    log.newLine();
                    System.out.println("[LOG] " + msg); // Pour debug
                }

                private static void calculerStat() {
                    try (BufferedWriter out = new BufferedWriter(new FileWriter(STAT_FILE))) {
                        int totalOui = 0, totalNon = 0;
                        Result plusParticipation = null;
                        List<Result> petitsEcarts = new ArrayList<>();

                        for (Result r : results) {
                            totalOui += r.getOui();
                            totalNon += r.getNon();

                            if (plusParticipation == null || r.getTauxParticipation() > plusParticipation.getTauxParticipation()) {
                                plusParticipation = r;
                            }
                            if (Math.abs(r.getOui() - r.getNon()) < 10) {
                                petitsEcarts.add(r);
                            }
                        }

                        out.write("R√©sultats sur " + results.size() + " communes :");
                        out.newLine();
                        boolean accepte = totalOui > totalNon;
                        out.write(String.format("%s √† %.1f%%",
                                accepte ? "Accept√©" : "Refus√©",
                                (totalOui * 100.0) / (totalOui + totalNon)));
                        out.newLine();
                        out.newLine();

                        out.write("Plus grande participation :");
                        out.newLine();
                        out.write(plusParticipation.toStringLong());
                        out.newLine();
                        out.newLine();

                        out.write("Petits √©carts (moins de 10 voix d'√©cart) :");
                        out.newLine();
                        for (Result r : petitsEcarts) {
                            out.write(r.toStringLong());
                            out.newLine();
                        }

                    } catch (IOException e) {
                        System.out.println("Erreur √† l'√©criture du fichier stats : " + e.getMessage());
                    }
                }
            }


// ==========================================================
// [39] LISTES & MOT-CLE `new` : QUAND L‚ÄôUTILISER
// ==========================================================

            /*
             * ‚úÖ 1. Cr√©ation d'une nouvelle liste ‚Üí on met `new`
             */
            ArrayList<String> noms = new ArrayList<>(); // nouvelle liste vide

            /*
             * ‚úÖ 2. Initialisation dans un constructeur ‚Üí on met `new`
             */
            public class Bibliotheque {
                private ArrayList<Livre> livres;

                public Bibliotheque() {
                    livres = new ArrayList<>(); // cr√©ation d'une liste vide au d√©part
                }
            }

            /*
             * ‚ùå 3. Quand une liste est re√ßue en param√®tre ‚Üí PAS de `new`
             */
            public class Bibliotheque {
                private ArrayList<Livre> livres;

                public Bibliotheque(ArrayList<Livre> livres) {
                    this.livres = livres; // on re√ßoit une liste d√©j√† existante ‚Üí pas besoin de la cr√©er
                }
            }

            /*
             * ‚ùå 4. Quand une m√©thode utilise une liste donn√©e ‚Üí PAS de `new`
             */
            public static void afficherNoms(ArrayList<String> noms) {
                for (String nom : noms) {
                    System.out.println(nom);
                }
            }

            /*
             * ‚úÖ 5. Si on veut r√©initialiser une liste ‚Üí on met `new`
             */
            noms = new ArrayList<>(); // vide la liste et recr√©e une nouvelle instance

// ==========================================================
// [40] LIAISON ENTRE OBJETS SANS HASHMAP (INSCRIPTIONS)
// ==========================================================

/*
 * ‚úÖ ID√âE CL√â :
 * On peut **lier deux objets entre eux directement**, sans passer par une HashMap.
 * Exemple : un Examen contient une liste d‚Äô√âtudiants,
 * et chaque √âtudiant contient une liste d‚ÄôExamens.

 * üîÅ Cette m√©thode fonctionne gr√¢ce √† des **listes locales** dans chaque classe,
 * et des **m√©thodes d‚Äôajout** comme `addEtudiant()` et `addExamen()`.

------------------------------------------------------------
 * üìò Examen.java
 * ‚Üí contient : List<Etudiant> etudiants;
 * ‚Üí m√©thode : void addEtudiant(Etudiant etu)
------------------------------------------------------------

 * üìò Etudiant.java
 * ‚Üí contient : List<Examen> examens;
 * ‚Üí m√©thode : void addExamen(Examen exa)
------------------------------------------------------------

 * ‚úÖ Exemple d‚Äôutilisation :
 * Quand on charge le fichier d‚Äôinscriptions :
 * ‚Üí pour chaque ligne d‚Äôinscription, on fait :
 *     exa.addEtudiant(etu);
 *     etu.addExamen(exa);

 * üîÅ Le lien est donc **cr√©√© des deux c√¥t√©s**, automatiquement.

------------------------------------------------------------
 * ‚úÖ POURQUOI C‚ÄôEST UTILE ?
------------------------------------------------------------

 * ‚ûï Avantages :
 * - Pas besoin de HashMap compliqu√©e
 * - Plus simple √† lire et manipuler
 * - Suffisant si on n‚Äôa pas des millions de donn√©es

 * ‚ûñ Inconv√©nients :
 * - Moins rapide qu‚Äôune Map pour retrouver un √©l√©ment
 * - Attention aux doublons si on ne v√©rifie pas avec `.contains()`

------------------------------------------------------------
 * ‚úÖ QUAND L‚ÄôUTILISER ?
------------------------------------------------------------

 * ‚Üí Cas typiques : relations bidirectionnelles
   - √âtudiants / Examens
   - Clients / Commandes
   - Joueurs / √âquipes
   - Cours / Professeurs

------------------------------------------------------------
 * üß† √Ä RETENIR
------------------------------------------------------------

 * üëâ Si tu veux lier deux classes sans HashMap :
 *   1. Ajoute une liste de l‚Äôautre objet dans chaque classe
 *   2. Cr√©e une m√©thode d‚Äôajout (addXXX) dans chaque classe
 *   3. Lors du chargement, appelle les deux m√©thodes

 * Exemple dans le code :
      exa.addEtudiant(etu);
      etu.addExamen(exa);
 */


// =======================================
// FIN DU FICHIER DE REVISION JAVA
// =======================================